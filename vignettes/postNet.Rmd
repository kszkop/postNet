---
title: "Post-transcriptional network modelling with postNet"
author: "Krzysztof J. Szkop, Kathleen Watt, Ola Larsson"
package: postNet
abstract: > 
  Post-transcriptional mechanisms play a central role in the regulation of gene expression, with protein levels partly determined by various features within target mRNAs. Emerging evidence indicates that most individual mRNAs contain multiple regulatory elements. This underscores the need for efficient bioinformatic tools that can capture and integrate multiple mRNA features to assess their combined impact on the proteome. Here, we present postNet modeling, a tool that enables in silico identification, integration, and modeling of mRNA features that influence post-transcriptional regulation of gene expression at a transcriptome-wide scale. Although geared towards studies of post-transcriptional regulation, postNet is highly customizable and can, in principle, be applied in a variety of other contexts to explain changes in a continuous numeric variable between two or more conditions/groups. This vignette provides details regarding the use of postNet, and demonstrates typical workflows and results interpretation. 
output: 
  BiocStyle::html_document:
    highlight: pygments
    toc: true
vignette: >
  %\VignetteIndexEntry{Post-transcriptional network modelling with postNet}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: vignette_references.bib
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, 
                      error = FALSE, 
                      warning = TRUE)
```

# Introduction

To enable efficient assessment of features underlying alterations in translational efficiencies we developed postNet, which includes methods to quantify and identify RNA features (e.g. nucleotide content, length of UTRs and CDS, folding energy of UTRs and CDS, RNA motifs, uORFs, codon composition etc.) associating with selective alterations in mRNA translation and statistical analysis of whether the catalogue of identified features appear to modulate translation in a distinct or overlapping fashion.

PostNet uses stepwise linear regressions to model changes in post-transcriptional regulation (translation, or translational offsetting) across subsets of regulated mRNAs and assesses the contribution of each feature included in the modelling in a hierarchical manner. This allows postNet to rank mRNA features according to their ability to explain changes in gene expression regulation. Furthermore, because of the hierarchical approach, the interdependence between different features is revealed. 

In the first phase of postNet modelling, each candidate feature is evaluated separately (i.e. using univariate linear models). This allows assessment of associations between changes in post-transcriptional regulation and each selected feature to provide an overview. Moreover, the univariate output is used to identify of a set of features for further modeling in phase two of the postNet analysis. In the second phase, postNet selects the feature that best explained the regulatory changes from phase one and adds additional features to the model in an iterative fashion, keeping covariance between features in the model assigned to the feature which appeared most influential. During each iteration, the best performing model (i.e. the feature showing the strongest association with the regulatory effect) is kept and features that do not explain any additional variation are discarded. This generates a hierarchical output that reveals dependence between RNA features (i.e. co-occurrence in mRNAs) identified under phase one. In the third and final phase of postNet analysis, the independent contribution of each of the features that emerged as significant from phase two is determined (i.e. in contrast to assigning covariance to the most influential feature under phase 2, such covariance is eliminated from the output to derive the independent contribution of each feature during phase three).

# Workflow 

PostNet was designed to accommodate a variety of inputs and biological contexts. A postNet analysis can consists of the following steps: 

1) Initialize a `postNetData` object with the `postNetStart()` function, containing curated reference mRNA sequences, gene sets of interest to be compared, and a regulatory effect measurement that will be used in downstream analyses. See [Setting up a postNet analysis](#settingUp) for details.
2) Identify and quantify mRNA sequence features, and compare them between gene sets of interest. See [Analysis of mRNA sequence features](#mRNAfeatures) for details.
3) Model post-transcriptional changes in gene expression using mRNA features (or other variables) underlying regulatory processes with the `featureIntegration()` function. See [Modelling post-transcriptional regulation](#modelling) for details.
4) Perform network analysis based on stepwise regression models to understand the independent and overlapping contribution of mRNA features to post-transcriptional regulation, and use identified features to predict regulation in other data sets using machine learning with the `rfPred()`function. See [Network analysis and prediction](#networkPred)
5) Explore relationships between mRNA features (or other variables) and regulatory effects using UMAP visualizations with the `plotFeaturesMap()`function. See [Visualize and explore relationships between mRNA features and regulation](#UMAPvis)
6) Optionally, perform functional enrichment analyses on the regulated gene sets of interest. See [Functional enrichment analyses with postNet](#enrichmentAnalysis) for details.

# Getting started

Here, we demonstrate a minimal example of the steps of a standard postNet analysis workflow using an example data set illustrating changes in mRNA translation, with default parameters. This includes compiling input data and selecting reference mRNA sequence annotations, enumeration of mRNA features in regulated gene sets of interest, modelling changes in mRNA translation efficiency using stepwise regression to identify the collection of mRNA features that best explain the observed regulation (omnibus model), network analysis visualizing the independent and overlapping regulatory contribution of mRNA features, and finally exploration of modelling results using UMAP visualizations.

```{r load_package_data, eval=TRUE, echo=TRUE} 
library(postNet)
data("postNetExample")
```

**Step 1:** A `postNetData` object containing regulated gene sets of interest along with the background set, a regulatory effect measurement (in this case, log2 fold changes in translation efficiency derived from ribosome profiling and RNAseq comparing cells responding to osmotic stress against controls [ref]), and reference mRNA sequence annotations in initialized using the `postNetStart()` function.   
```{r gettingStartedInput, eval=TRUE, echo=TRUE}
# Prepare custom gene lists and regulatory effect measurement:
myGenes <- postNetExample$geneList
myBg <- postNetExample$background
myEffect <- postNetExample$effect

str(myGenes)
str(myBg)
str(myEffect)

```

```{r gettingStartedInitialize, eval=TRUE, echo=TRUE, results='hide'}
# Initialize a postNetData object:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   selection = "random",
   setSeed = 123,
   source = "load", 
   species = "human"
 )

```

**Step 2:** mRNA features that may influence post-transcriptional regulation of gene expression are enumerated. In this minimal example, the length and nucleotide content of 5'UTR regions are calculated and compared between gene sets. However, numerous other features across all sequence regions can be examined (see [Analysis of mRNA sequence features](#mRNAfeatures)). These analyses allow both statistical comparisons of mRNA features between gene sets of interest, and generate outputs that can be used to assess the contribution of a given mRNA feature to the observed regulatory effect in the modelling step. 

```{r gettingStartedenumerate, eval=TRUE, echo=TRUE}
# Quantify the length and nucleotide content of the 5'UTR and compare between regulated gene sets 
len <- lengthAnalysis(ptn = ptn, 
                      region = c("UTR5"), 
                      comparisons = list(c(0,1),c(0,2),c(1,2)),
                      plotOut = TRUE,
                      plotType = 'boxplot',
                      pdfName = "Example")
                  
 str(len)
 
 content_UTR5 <- contentAnalysis(ptn = ptn, 
                           region = c("UTR5"),
                           comparisons = list(c(0,1),c(0,2),c(1,2)), 
                           contentIn = c("GC"),
                           plotOut = TRUE,
                           plotType = "ecdf",
                           pdfName = "Example")
                      
 str(content_UTR5)

```

```{r gettingStartedenumeratePDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
library(magick)
image_read_pdf("Example_UTR5_boxplot_lengthAnalysis.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_boxplot_lengthAnalysis.png")

image_read_pdf("Example_UTR5_GC_content.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_GC_content.png")

# Read each image
img1 <- image_read("Figures/Example_UTR5_boxplot_lengthAnalysis.png")
img2 <- image_read("Figures/Example_UTR5_GC_content.png")

# Append them horizontally
combined <- image_append(c(img1, img2), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_UTR5_features.png")

```

```{r gettingStartedenumeratePNGS, echo=FALSE, fig.wide = TRUE, fig.cap="Comparisons of 5'UTR length and GC content between mRNA belonging to regulated gene sets."}
knitr::include_graphics("Figures/combined_UTR5_features.png")

```

```{r gettingStartedhidePlots, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_boxplot_lengthAnalysis.pdf", "Example_UTR5_GC_content.pdf","Figures/Example_UTR5_boxplot_lengthAnalysis.png","Figures/Example_UTR5_GC_content.png"))
```

**Step 3:** Changes in translation efficiency are modeled using the `featureIntegration` function which performs stepwise regression to identify the collection of features that best explains the observed regulation. In this minimal example, a set of pre-calculated features is used including both *cis*-acting (enumerated mRNA features) and *trans*-acting (signatures of upstream regulatory pathways) factors. 

```{r gettingStartedFeatureInt, eval=TRUE, echo=TRUE}
# Prepare the list of pre-calculated features to be used in modelling (for example, the 'len' and 'content_UTR' variables defined in the previous step can be included) 
features <- postNetExample$features
str(features)

# Group the features according to category (optional)
group = c("UTR5", "UTR3", rep("UTR5",3), rep("UTR3",4), "CDS", "CDS", "UTR5", "UTR5", 
                rep("Pathway",2),"UTR5", rep("Pathway",2))
groupColour = c('#834b62','#6699cc','#e9724c','#fff275')
names(groupColour) <- c("UTR5","CDS", "UTR3","Pathway")

# Run feature integration modelling using stepwise regression
ptn <- featureIntegration(ptn = ptn, 
                          features = features, 
                          pdfName = "omnibus", 
                          regOnly = T, 
                          allFeat = F,
                          analysis_type = "lm",
                          covarFilt = 20,
                          comparisons = list(c(1,2)),
                          lmfeatGroup = group,
                          lmfeatGroupColour = groupColour,
                          NetModelSel = 'omnibus')

```

```{r gettingStartedFeatureIntPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
library(magick)
image_read_pdf("omnibus_lm_translationUp_translationDown_network.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/omnibus_lm_translationUp_translationDown_network.png")

image_read_pdf("omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.png")

```

```{r gettingStartedFeatureIntNetworkPNG, echo=FALSE, fig.cap="Network plot of the results of the stepwise regression omnibus model."}
knitr::include_graphics("Figures/omnibus_lm_translationUp_translationDown_network.png")

```

```{r gettingStartedhideFeatureIntPlots, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("omnibus_lm_translationUp_translationDown_Cockman_etal_2020_classicTOP_individually.pdf", "omnibus_lm_translationUp_translationDown_Down_individually.pdf","omnibus_lm_translationUp_translationDown_FinalModel.pdf","omnibus_lm_translationUp_translationDown_Gandin_etal_2016_mTOR_transUp_individually.pdf","omnibus_lm_translationUp_translationDown_Guan_etal_2017_Tg1_transUp_individually.pdf","omnibus_lm_translationUp_translationDown_network.pdf","omnibus_lm_translationUp_translationDown_uORFs_ATG_strong_individually.pdf","omnibus_lm_translationUp_translationDown_UTR3_C_individually.pdf","omnibus_lm_translationUp_translationDown_UTR3_T_individually.pdf","omnibus_lm_translationUp_translationDown_UTR3_T_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_A_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_length_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_T_individually.pdf"))
```

**Step 4:** The `plotFeaturesMap()` function is used to visualize the relationship between translation efficiency and different features that were identified in the modelling step as significantly contributing to the observed translational regulation. These visualizations are also useful for exploring the overlaps between different features within the same mRNAs.  

```{r gettingStartedPlotFeaturesMap, eval=TRUE, echo=TRUE}

ptn <- plotFeaturesMap(ptn,
                regOnly = TRUE,
                comparisons = list(c(1,2)),
                featSel = names(ptn_selectedFeatures(ptn, 
                                               analysis_type = "lm",
                                               comparison = 1)),
                remBinary = T,
                featCol = "UTR5_SCSCGS",
                scaled = F,
                remExtreme = 0.1,
                pdfName = 'Example')

```

```{r gettingStartedPlotFeaturesMapPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
library(magick)
image_read_pdf("Example_UTR5_SCSCGS_featureUMAP.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_SCSCGS_featureUMAP.png")

```

```{r gettingStartedPlotFeaturesMapPNG, echo=FALSE, fig.wide = TRUE, fig.cap="UMAP visualizing changes in translation efficiency (Effect) generated based on features identified in the omnibus model (left), with mRNAs containing SCSCGS motifs in the 5Â´UTR coloured (right)."}
knitr::include_graphics("Figures/Example_UTR5_SCSCGS_featureUMAP.png")

```

```{r gettingStartedhidePlotFeautresMaps, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_SCSCGS_featureUMAP.pdf"))
```

This example provided an overview of a minimal postNet workflow. Full details of alternative workflows and additional inputs and options are discussed in detail in the following sections. 

<a name="settingUp"/>

# Setting up a postNet analysis

The basic workflow of a postNet analysis aims to explain the post-transcriptional regulatory fate of mRNA based on their repertoire of *cis*-acting sequence features and/or interactions with *trans*-acting factors. Three basic inputs are required to run a postNet analysis:

1) Reference sequence annotations that will be used to identify and/or enumerate regulatory features.
2) Gene sets of interest that undergo post-transcriptional regulation.
3) A regulatory effect measurement, for example the log2 fold change in translation efficiency between an experimental and control condition.

These inputs are compiled at the start of the analysis by initializing a `postNetData` object using the `postNetStart()` function. This class of object serves as the container for storing inputs and some outputs generated during the analysis, and is designated by `ptn` in the example code provided here. The following sections describe the different options and customizations available, along with examples illustrating how to set up a postNet analysis.

Throughout this vignette, we will use example data provided with the package to illustrate the implementation of different analyses. These data are published in the study by Krokowski et al. [@Krokowski2022], where changes in translation efficiency were measured using ribosome profiling and RNA-seq in immortalized human corneal epithelial cells responding osmotic stress (500 mOsm, NaCl) for 1 h, along with controls. Genes that were translationally activated or suppressed under osmotic stress were identified using the anota2seq algorithm [ref].

## Initializing a postNetData object using gene lists

The most flexible implementation of postNet allows gene lists of interest and regulatory effect measurements to be supplied from custom sources. Here, the  `postNetStart()` function will be used with the `geneList`, `geneListcolours`, `customBg`, and `effectMeasure` parameters to initialize the `postNetData` object.    

Depending on the aim of the analysis, different inputs can be provided. In the case where the goal is simply to enumerate sequence features in genes of interest without statistical comparisons, `geneList` can be a single list of gene IDs with no background gene set. To perform statistical comparisons, one or more gene sets of interest must be provided, either with or without a custom background gene set (`customBg` parameter). Although optional, it is strongly recommended to carefully consider that the appropriate background is used. Typically, this would be all genes in the given data set passing expression and/or reproducibility thresholds. When providing custom gene lists, it is also required to specify colours (`geneListcolours` parameter) that will be used in visualizations generated at various steps of the analysis.

For each gene provided as part of a gene set of interest or background set, you must provide a regulatory effect measurement. As postNet is designed for examining post-transcriptional regulation, this would typically be the log2 fold changes in mRNA translation efficiency or expression between two conditions. However, other continuous numeric variables representing a change between two conditions could also be used, allowing a high degree of flexibility in potential applications. 

The example below illustrates the set-up of a postNet analysis allowing identification of mRNA features and statistical comparisons between sets of translationally activated and suppressed genes, as well as modelling and network analysis to identify features associated with changes in translational regulation and their interdependence.  

```{r postNetStartGeneList, eval=TRUE, echo=TRUE}

# Genes of interest should be provided in a named list.
 myGenes <- postNetExample$geneList
 str(myGenes)
 
# All gene IDs in the list should be present in the background.
 myBg <- postNetExample$background
 str(myBg)
 
# The regulation effect measurement must be named with the same gene IDs
# present in the background (or the gene list if no custom background is provided).
 myEffect <- postNetExample$effect
 str(myEffect)

```

```{r postNetStartGeneListInit, eval=TRUE, echo=TRUE, results = 'hide'}

# Initialize the postNetData object with custom gene lists:
 ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   selection = "random",
   setSeed = 123,
   source = "load", 
   species = "human"
 )

```

## Initializing a postNetData object using an anota2seq object

A `postNetData` object can also be constructed directly downstream of running an analysis using the [Anota2seq](https://bioconductor.org/packages/anota2seq) package to identify differentially translated genes. Here, the  `postNetStart()` function will be used with the `ads`, `regulation`, `contrast`, `regulationGen`, and `contrastSel` parameters to initialize the `postNetData` object.  
 
*Anota2seq* can be applied using data from both polysome and ribosome profiling techniques, and categorizes genes into three different regulatory modes: 
1) Abundance, where changes in mRNA levels can be explained by transcription or mRNA stability.
2) Translation, where polysome-association is altered without a change in total mRNA level (this mode is expected to alter protein levels).
3) Buffering/translational offsetting, where polysome-association is maintained while total mRNA level changes (this mode is not expected to alter protein levels).

An `Anota2seqDataSet` can be provided using the `ads` parameter of `postNetStart()`. The `regulation` parameter allows the user to select which sets of regulated genes identified using *anota2seq* will be used in statistical comparisons and downstream feature integration modelling and network analysis. In addition to the three regulatory modes listed above, where changes in both total and translated mRNA are taken into account, it is also possible to examine differences in total and translated mRNA independently. Gene sets can be selected from multiple contrasts in *anota2seq* specified with the `contrast` parameter (see the [anota2seq vignette](https://bioconductor.org/packages/release/bioc/vignettes/anota2seq/inst/doc/anota2seq.pdf) for more details).    

The regulatory effect measurement is taken directly from the `Anota2seqDataSet` object, and is specified by the `regulationGen` parameter. *Anto2seq* calculates sets of fold changes for each gene, in each regulatory mode. Although gene sets from all regulatory modes and contrasts can be selected for statistical comparisons, only one "general" regulatory effect measurement can be supplied (i.e., fold changes in translation efficiency, *or* buffering, etc.), so consideration should be given to downstream modelling where the mRNA features (and/or other input signatures) quantified in the gene sets specified by `regulation` will be used to explain changes in the regulatory effect measurement specified by `regulationGen`. Similarly to the gene sets, the regulatory effect measurement can be selected from any contrast from the *anota2seq* analysis using the `contrastSel` parameter.        

When an `Anota2seqDataSet` is supplied, the appropriate background gene set, and colours for each gene list will be automatically retrieved.  

The example below illustrates the set-up of a postNet analysis using the output of *anota2seq*, `ads`.  
```{r GetAds, eval=TRUE, echo=TRUE, results = 'hide'}

library(anota2seq)

# Initialize Anota2seqDataSet using example data (see anota2seq vignette for details)
 ads <- anota2seq::anota2seqDataSetFromMatrix(
    dataP = postNetExample$ads_data$dataP,
    dataT = postNetExample$ads_data$dataT,
    phenoVec = postNetExample$ads_data$phenoVec,
    batchVec = c(1, 2, 3, 4, 1, 2, 3, 4),
    dataType = "RNAseq",
    normalize = FALSE)
    
# Run an anota2seq analysis:
# Note that the quality control and residual outlier testing are not 
# performed to limit the running time of this example. For full details 
# on running an analysis please see the anota2seq vignette and help manual.
 ads <- anota2seqRun(ads,
    performQC = FALSE, 
    performROT = FALSE, 
    useProgBar = FALSE)
```

```{r GetAdsrm, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("ANOTA2SEQ_rvm_fit_for_all_contrasts_group.jpg"))
```

This postNet analysis will allow identification of mRNA features and comparison between translationally activated and suppressed genes, as well as buffered (total mRNA up and down) genes from contrast 1. Feature integration and network analysis will model the fold changes in translation efficiency from contrast 1. Note that in this example, if the buffering gene sets are included in modelling comparisons, the regulatory effect measurement values for these genes will be the fold changes in translation efficiency.   

```{r postNetStartAds, eval=TRUE, echo=TRUE, results = 'hide'}

# Initialize the postNetData object:
  ptn_withAds <- postNetStart(
      ads = ads,
      regulation = c("translationUp","translationDown","bufferingmRNAUp","bufferingmRNADown"),
      contrast = c(1,1,1,1),
      regulationGen = "translation",
      contrastSel = 1,
      selection = "random",
      setSeed = 123,   # ensures reproducibility of random isoform selection
      source = "load",
      species = "human"
    )
  
```

## Reference sequence annotations

Reference sequence annotations in postNet are divided according to different regions of mRNA molecules (5'UTR, CDS, and 3'UTR) to allow regions to be compared separately. The `source` parameter of the `postNetStart()` function allows the user to select from several in-built sequence annotations provided with the package, retrieve sequence annotations directly from the NCBI RefSeq database [@OLeary2016], or provide custom sequence annotations. Optionally, UTR sequences can also be adjusted if more precise sequences are available, for example those experimentally determined using approaches like CAGE, QuantSeq, or long-read sequencing, etc.

It is highly recommended to use reference sequence annotations that correspond to those that were used in generating the input gene lists. For example, if RNA sequencing reads were counted using Ensembl gene/transcript annotations, these may not always correspond well to the sequences defined by RefSeq annotations, even if identifiers have been converted to be compatible. When running `postNetStart()`, a warning message describing differences in gene identifiers between the input gene lists and the reference sequence annotations will be printed to the console. Minor differences may be acceptable depending on the application. However, larger differences may warrant either reprocessing of input data, or selecting a more compatible reference sequence annotation before proceeding with the analysis.

### Loading in-built reference sequence annotations

By default, `source = "load"` meaning `postNetStart()` will load one of the in-built reference sequence annotations provided with the package. This option is available when `species = "human"` or `"mouse"`, and several versions can be chosen from with the `version` parameter. All in-built annotations are based on different releases of NCBI RefSeq GRCh38 (human) and GCRm39 (mouse) genome assemblies and corresponding transcript annotations.     

It is possible to check which RefSeq release versions have in-built annotations available within the package using the `checkAvailableVersions()` function.

```{r RefSeqCheckVersions, eval=TRUE, echo=TRUE}

# List RefSeq release versions of available annotations in the package
checkAvailableVersions(species = "human")
checkAvailableVersions(species = "mouse")

```

A `postNetData` object can then be initialized using the in-built reference sequence annotations, in this case using the RefSeq ver_40.202408 release version for human. Note that if no version is specified, the latest release will be used.

```{r RefSeqLoad, eval=FALSE, echo=TRUE}

# Prepare custom gene lists and regulatory effect measurement using example data:
myGenes <- postNetExample$geneList
myBg <- postNetExample$background
myEffect <- postNetExample$effect

# Initialize a postNetData object using in-built annotations for human:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "load", 
   species = "human",
   version = "ver_40.202408"
 )

```

### Retrieving or constructing reference sequence annotations from the NCBI RefSeq database

In addition to the in-built annotations, it is also possible to either retrieve or construct reference sequences for any RefSeq release version. Currently, only human and mouse are supported with these options. 

By specifying `source = "create"` in `postNetStart()`, annotation files from the most recent RefSeq release version for the indicated species will be automatically downloaded and used to construct a new reference sequence annotation locally. Note that downloads may take several minutes, and files will be stored in the working directory. Using this option requires an internet connection.

```{r RefSeqCreate, eval=FALSE, echo=TRUE}

# Initialize a postNetData object creating new RefSeq reference sequence annotations for human:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "create", 
   species = "human",
 )

```

Alternatively, two additional off-line methods are available to construct reference sequence annotations if files have already been downloaded from [RefSeq](https://www.ncbi.nlm.nih.gov/refseq/) and are available locally. This can be done by specifying `source = "createFromSourceFiles"` in `postNetStart()`, and providing the the RNA GBFF ("rna.gbff"), RNA FASTA ("rna.fna"), and genomic GFF ("genomic.gff") files. These files must be provided using the `rna_gbff_file`, `rna_fa_file`, and `genomic_gff_file` parameters of `postNetStart()`.    

```{r RefSeqCreateFromSourceFiles, eval=FALSE, echo=TRUE}

#  The required RefSeq annotation files downloaded from the NCBI database will 
#  have the following naming:
#  - "example_rna.gbff.gz"
#  - "example_rna.fa.gz"
#  - "example_genomic.gff.gz"

# Initialize a postNetData object creating a new RefSeq reference sequence annotation 
# from source files:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "createFromSourceFiles",
   species = "human",
   rna_gbff_file = "example_rna.gbff.gz",
   rna_fa_file = "example_rna.fa.gz",
   genomic_gff_file = "example_genomic.gff.gz"
 )

```

For added flexibility in defining sequence regions, it is also possible to assemble reference sequence annotations from a FASTA file using `source = "createFromFasta"` in `postNetStart()`. This option requires that a FASTA file be provided using the `fastaFile` parameter, along with an additional file specifying the coordinates of the mRNA sequence regions (provided with the `posFile` parameter). This position file must tab delimited and have columns indicating the transcript id, 5'UTR length, end of the coding sequence, and the total transcript length (see example below). Optionally, a genomic GFF file can also be provided using the `genomic_gff_file` parameter, however, if not GFF is provided the latest version for the indicated species will be automatically downloaded from the RefSeq database.  

```{r RefSeqCreateFromFasta, eval=FALSE, echo=TRUE}

# An example of the required format for the posFile parameter ("positions.txt"):
# id	UTR5_len	cds_stop	total_length
# NM_000014	70	4495	4610
# NM_000015	70	943	1285
# NM_000016	79	1345	2261

# Initialize a postNetData object creating a new RefSeq reference sequence annotation 
# from source files:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "createFromFasta",
   species = "human",
   fasta_file = "_rna.fa.gz",
   posFile  = "positions.txt"
   genomic_gff_file = "_genomic.gff.gz"
 )

```

### Using custom reference sequence annotations

The transcriptome is highly diverse, with mRNA isoform expression patterns varying across cell types [ref], and between normal and disease states [ref]. The sequences of mRNA molecules can also be dynamically regulated through processes such as alternative splicing [ref], altered transcription start site usage [ref], and alternative polyadenylation [ref]. Analyses relating mRNA sequence features to post-transcriptional regulation will benefit from more precise sequence annotations if these are available.

Custom reference sequence annotations can be used with the `postNetStart()` function and may be desirable in cases when working with data from species not currently supported by the options described above, with annotations other than those in the NCBI RefSeq database, or if sequences have been experimentally determined. A pre-prepared reference sequence annotation file can be provided using the `customFile` parameter. This file must be tab delimited and contain the columns: transcriptID, geneID, UTR5_seq, CDS_seq, and UTR3_seq. 

```{r RefSeqCustom, eval=FALSE, echo=TRUE}

# An example of the required format for the customFile parameter ("customSequences.txt"):
# id	geneID	UTR5_seq	CDS_seq	UTR3_seq
# NM_000014	A2M	GGGACCAG...	ATGGGGAA...	AGACCACA...

# Initialize a postNetData object with a custom reference sequence annotation file:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "custom",
   species = NULL,
   customFile = "customSequences.txt"
 )

```

### Selecting transcript isoforms

Using sequence annotations provided with the package or built from the RefSeq database, by default, postNet will perform gene-level analyses. For genes with multiple mRNA isoforms, the `selection` parameter of the `postNetStart()` function can be used to specify which isoforms will be considered in analyses. Depending on the application, it may sometimes be of interest to consider the longest or shortest mRNA isoforms for each gene. However, selecting the extremes for all genes may skew the results for some types of analysis. By default, isoforms for each gene will be selected at random to prevent a systematic length bias. However, it is important to note that each time the `postNetStart()` function is run, different isoforms may be selected leading to slight variations in results. To ensure reproducibility of isoform selection between different runs of the `postNetStart()` function, it is necessary to use the `setSeed` parameter.  

It is also possible to perform transcript-level analyses with postNet by supplying custom sequence annotations as described above (I guess the featureIntegration using isoform-level data might suffer from the same issue as anota2seq due to correlations between isoforms of the same genes? Should probably mention this somewhere).

```{r IsoformSel, eval=FALSE, echo=TRUE}

# Initialize a postNetData object with random, reproducible mRNA isoform selection:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "load",
   species = "human",
   selection = "random",
   setSeed = 123
 )

```
 
### Adjusting UTR sequence annotations

Numerous sequencing approaches are available to specifically map UTRs, such as CAGE/nanoCAGE [ref] and QuantSeq [ref]. For this reason, it is also possible to adjust only UTR sequences if more specific data is available for your experimental condition or model of interest.

Custom UTR sequences will replace UTRs in an existing annotation file when using the `adjObj` and `region_adj` parameters of the `postNetStart()` function. A list of custom sequences must be provided, specifying which UTR region(s) should be replaced. If custom UTR sequences are available for some, but not all genes in the existing sequence annotation, whether genes and isoforms without custom sequences are kept or discarded from the analysis can by controlled using the `excl` parameter. The `keepAll` parameter can also be used to control how custom UTR isoform sequences are stored for genes with multiple isoforms.        

```{r AdjObj, eval=TRUE, echo=TRUE}

# Create the adjObj list with custom 5'UTR sequences to replace those in the loaded annotation file
myUTR5seqs <- ptn_sequences(ptn, "UTR5")
myIDd <- ptn_id(ptn, "UTR5")
names(myUTR5seqs) <- myIDd
customUTR5s <-  list(UTR5 = myUTR5seqs)
str(customUTR5s)

```
 
```{r AdjustUTRs, eval=FALSE, echo=TRUE}

# Initialize a postNetData object with custom 5'UTR sequences, replacing the 5'UTR sequences
# in the loaded annotation file with custom ones where available, and discarding all isoforms 
# without custom sequences. Genes with no custom sequence will retain all isoforms from the original annotation:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "load",
   species = "human",
   selection = "random",
   setSeed = 123,
   adjObj = customUTR5s,
   region_adj = "UTR5",
   excl = FALSE,
   keepAll = FALSE
 )

```
 
 
<a name="mRNAfeatures"/>

# Analysis of mRNA sequence features

## Length of sequence regions

## Nucleotide content

## Folding energy

## upstream open reading frames (uORFs)

## Motif discovery using STREME

## Motif enumeration

## Codon and amino acid usage

### Selecting enriched or depleted codons or amino acids

### Enumerating codons or amino acids 

<a name="modelling"/>

# Modelling and network analysis of post-transcriptional regulation 

## Selecting features for modelling

### *Cis*-acting features

### *Trans*-acting features

### Creating the feature list

### Highly correlated variables 

## Post-transcriptional network modelling with stepwise linear regression

### Overview

### Univariate models

### Omnibus model

### Adjusted model

### Understanding covariance and feature correlations

### Network visualizations

### Feature visualizations

## Post-transcriptional network modelling with random forest classification

### Overview

### Receiver Operating Characteristic (ROC) analysis

### Feature Importance


<a name="UMAPvis"/>

# Visualize and explore relationships between mRNA features and regulatory effects 

## Plotting UMAPs

### Clustering and colouring options

### Scaling and binary features 


<a name="networkPred"/>

# Predicting post-transcriptional regulation

## Selecting features to predict post-transcriptional regulation

## Predicting regulation in a new data set 


<a name="enrichmentAnalysis"/>

# Functional enrichment and threshold-independent signature analyses with postNet

In addition to tools for identifying and enumerating sequence features of mRNA and modeling networks of post-transcriptional regulation, postNet can also be used to perform enrichment analyses including implementations of GSEA, GAGE, and GO term analysis to provide functional insights into gene sets of interest. It is also possible to examine the regulation of gene signatures in your dataset in a threshold-independent manner, providing insights into possible mechanisms explaining observed regulation and allowing comparisons between datasets.  

## Slope filtering with an anota2seq object

When performing GSEA, GAGE, or GO term analysis using the output of an `anota2seq` analysis, it is often necessary to filter the input genes and log2 fold changes for the "translation" and "buffering" regulatory modes prior to performing enrichment analyses. This is due to that the slopes fitted by the anota2seq APV models can sometimes have unrealistic values, or suggest unlikely translational regulation, impacting the analysis of changes in translation or translational buffering (or offsetting). Filtering out genes with these unrealistic slopes is especially important for GSEA and GAGE analyses, which rely on rankings. For analyses relying on hypergeometric tests, such as GO term enrichment, the impact of filtering on the analysis is likely to be more negligible. However, slope filtering is still recommended. The `slopeFilt` function identifies these genes with unrealistic slopes, allowing them to be removed from downstream analyses. Note that in high-quality data sets few genes will require slope filtering, but filtering thresholds can be adjusted with the `minSlope` and `maxSlope` parameters. 

```{r slopeFilt, eval=TRUE, echo=TRUE}

# Get the genes to be filtered out of downstream enrichment analyses 
# using the buffering regulatory mode:
 filtOutGenes <- slopeFilt(ads,
                  regulationGen = "buffering",
                  contrastSel = 1)
                
```

The output of the slopeFilt function can be directly supplied to downstream enrichment analysis functions using the `genesSlopeFiltOut` parameter.  
```{r slopeFiltStr, eval=TRUE, echo=TRUE}
str(filtOutGenes)
```
 
## Performing GSEA with a postNetData object
A. Subramanian
Mootha, V.

MSigDB
```{r GSEAmsigDB, eval=FALSE, echo=TRUE}

# If using a GSEA collection from MSigDB, check the available versions:
 version <- msigdb::getMsigdbVersions()
 str(version)
 
# Retrieve the MSigDB data for "human":
 msigdbOut <- msigdb::getMsigdb(org = "hs", id = "SYM", version = version)

# Check the available collections or subcollections:
 msigdb::listCollections(msigdbOut)
 msigdb::listSubCollections(msigdbOut)
 
# Run GSEA on the C5 collection with GO:BP and specific terms:
 ptn <- gseaAnalysis(ptn = ptn,
                    collection = "c5",
                    subcollection = "GO:BP",
                    subsetNames = c("GOBP_CELL-CELL_SIGNALING_BY_WNT",
                    "GOBP_ENDOCYTOSIS"),
                    name = "c5_Example")

```

In addition to the collections in MSigDB, GSEA can also be run using custom gene sets using the `geneSet` parameter.
```{r GSEAcustom, eval=FALSE, echo=TRUE}

# Create example custom gene sets for GSEA:
set1 <- sample(myGenes[[1]], 100)
set2 <- sample(myGenes[[2]], 100)
inSet <- list(Set1 = set1, Set2 = set2)

# Run GSEA on custom gene sets:
 ptn <- gseaAnalysis(ptn = ptn,
                    geneSet = inSet,
                    name = 'Example')

# Extract the significant enrichment results from the postNetData object:
 gseaOut <- ptn_GSEA(ptn, 
                     threshold = 0.05)
 
 # Plot GSEA results:
 gseaPlot(ptn = ptn,
          termNames = gseaOut$Term[1])
```

### Plotting GSEA results

```{r GSEAplotting, eval=FALSE, echo=TRUE}

# Extract the significant enrichment results from the postNetData object:
 gseaOut <- ptn_GSEA(ptn, 
                     threshold = 0.05)
 
 # Plot GSEA results:
 gseaPlot(ptn = ptn,
          termNames = gseaOut$Term[1])
```


## GAGE analysis with a postNetData object

## GO term analysis with a postNetData object

### Plotting GO term analysis results

## miRNA enrichment analysis with a postNetData object

## Threshold-independent analysis of gene signatures

### Assessing gene signatures using the gene list workflow

### Assessing signatures from the anota2seq object workflow

### Generating gene signature heatmaps



# References
