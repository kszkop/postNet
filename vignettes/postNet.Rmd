---
title: "Post-transcriptional network modelling with postNet"
author: "Krzysztof J. Szkop, Kathleen Watt, Ola Larsson"
package: postNet
abstract: > 
  Post-transcriptional mechanisms play a central role in the regulation of gene expression, with protein levels partly determined by various features within target mRNAs. Emerging evidence indicates that most individual mRNAs contain multiple regulatory elements. This underscores the need for efficient bioinformatic tools that can capture and integrate multiple mRNA features to assess their combined impact on the proteome. Here, we present postNet modeling, a tool that enables in silico identification, integration, and modeling of mRNA features that influence post-transcriptional regulation of gene expression at a transcriptome-wide scale. Although geared towards studies of post-transcriptional regulation, postNet is highly customizable and can, in principle, be applied in a variety of other contexts to explain changes in a continuous numeric variable between two or more conditions/groups. This vignette provides details regarding the use of postNet, and demonstrates typical workflows and results interpretation. 
output: 
  BiocStyle::html_document:
    highlight: pygments
    toc: true
vignette: >
  %\VignetteIndexEntry{Post-transcriptional network modelling with postNet}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: vignette_references.bib
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, 
                      error = FALSE, 
                      warning = TRUE)
```

# Introduction

To enable efficient assessment of features underlying alterations in translational efficiencies we developed postNet, which includes methods to quantify and identify RNA features (e.g. nucleotide content, length of UTRs and CDS, folding energy of UTRs and CDS, RNA motifs, uORFs, codon composition etc.) associating with selective alterations in mRNA translation and statistical analysis of whether the catalogue of identified features appear to modulate translation in a distinct or overlapping fashion.

PostNet uses stepwise linear regressions to model changes in post-transcriptional regulation (translation, or translational offsetting) across subsets of regulated mRNAs and assesses the contribution of each feature included in the modelling in a hierarchical manner. This allows postNet to rank mRNA features according to their ability to explain changes in gene expression regulation. Furthermore, because of the hierarchical approach, the interdependence between different features is revealed. 

In the first phase of postNet modelling, each candidate feature is evaluated separately (i.e. using univariate linear models). This allows assessment of associations between changes in post-transcriptional regulation and each selected feature to provide an overview. Moreover, the univariate output is used to identify of a set of features for further modeling in phase two of the postNet analysis. In the second phase, postNet selects the feature that best explained the regulatory changes from phase one and adds additional features to the model in an iterative fashion, keeping covariance between features in the model assigned to the feature which appeared most influential. During each iteration, the best performing model (i.e. the feature showing the strongest association with the regulatory effect) is kept and features that do not explain any additional variation are discarded. This generates a hierarchical output that reveals dependence between RNA features (i.e. co-occurrence in mRNAs) identified under phase one. In the third and final phase of postNet analysis, the independent contribution of each of the features that emerged as significant from phase two is determined (i.e. in contrast to assigning covariance to the most influential feature under phase 2, such covariance is eliminated from the output to derive the independent contribution of each feature during phase three).

# Workflow 

PostNet was designed to accommodate a variety of inputs and biological contexts. A postNet analysis can consists of the following steps: 

1) Initialize a `postNetData` object with the `postNetStart()` function, containing curated reference mRNA sequences, gene sets of interest to be compared, and a regulatory effect measurement that will be used in downstream analyses. See [Setting up a postNet analysis](#settingUp) for details.
2) Identify and quantify mRNA sequence features, and compare them between gene sets of interest. See [Analysis of mRNA sequence features](#mRNAfeatures) for details.
3) Model post-transcriptional changes in gene expression using mRNA features (or other variables) underlying regulatory processes with the `featureIntegration()` function. See [Modelling post-transcriptional regulation](#modelling) for details.
4) Perform network analysis based on stepwise regression models to understand the independent and overlapping contribution of mRNA features to post-transcriptional regulation, and use identified features to predict regulation in other data sets using machine learning with the `rfPred()`function. See [Network analysis and prediction](#networkPred)
5) Explore relationships between mRNA features (or other variables) and regulatory effects using UMAP visualizations with the `plotFeaturesMap()`function. See [Visualize and explore relationships between mRNA features and regulation](#UMAPvis)
6) Optionally, perform functional enrichment analyses on the regulated gene sets of interest. See [Functional enrichment analyses with postNet](#enrichmentAnalysis) for details.

# Getting started

Here, we demonstrate a minimal example of the steps of a standard postNet analysis workflow using an example data set illustrating changes in mRNA translation, with default parameters. This includes compiling input data and selecting reference mRNA sequence annotations, enumeration of mRNA features in regulated gene sets of interest, modelling changes in mRNA translation efficiency using stepwise regression to identify the collection of mRNA features that best explain the observed regulation (omnibus model), network analysis visualizing the independent and overlapping regulatory contribution of mRNA features, and finally exploration of modelling results using UMAP visualizations.

```{r load_package_data, eval=TRUE, echo=TRUE} 
library(postNet)
data("postNetExample")
```

**Step 1:** A `postNetData` object containing regulated gene sets of interest along with the background set, a regulatory effect measurement (in this case, log2 fold changes in translation efficiency derived from ribosome profiling and RNAseq comparing cells responding to osmotic stress against controls [ref]), and reference mRNA sequence annotations in initialized using the `postNetStart()` function.   
```{r gettingStartedInput, eval=TRUE, echo=TRUE}
# Prepare custom gene lists and regulatory effect measurement:
myGenes <- postNetExample$geneList
myBg <- postNetExample$background
myEffect <- postNetExample$effect

str(myGenes)
str(myBg)
str(myEffect)

```

```{r gettingStartedInitialize, eval=TRUE, echo=TRUE, results='hide'}
# Initialize a postNetData object:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   selection = "random",
   setSeed = 123,
   source = "load", 
   species = "human"
 )

```

**Step 2:** mRNA features that may influence post-transcriptional regulation of gene expression are enumerated. In this minimal example, the length and nucleotide content of 5'UTR regions are calculated and compared between gene sets. However, numerous other features across all sequence regions can be examined (see [Analysis of mRNA sequence features](#mRNAfeatures)). These analyses allow both statistical comparisons of mRNA features between gene sets of interest, and generate outputs that can be used to assess the contribution of a given mRNA feature to the observed regulatory effect in the modelling step. 

```{r gettingStartedenumerate, eval=TRUE, echo=TRUE}
# Quantify the length and nucleotide content of the 5'UTR and compare between regulated gene sets 
len <- lengthAnalysis(ptn = ptn, 
                      region = c("UTR5"), 
                      comparisons = list(c(0,1),c(0,2),c(1,2)),
                      plotOut = TRUE,
                      plotType = 'boxplot',
                      pdfName = "Example")
                  
 str(len)
 
 content_UTR5 <- contentAnalysis(ptn = ptn, 
                           region = c("UTR5"),
                           comparisons = list(c(0,1),c(0,2),c(1,2)), 
                           contentIn = c("GC"),
                           plotOut = TRUE,
                           plotType = "ecdf",
                           pdfName = "Example")
                      
 str(content_UTR5)

```

```{r gettingStartedenumeratePDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
library(magick)
image_read_pdf("Example_UTR5_boxplot_lengthAnalysis.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_boxplot_lengthAnalysis.png")

image_read_pdf("Example_UTR5_GC_content.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_GC_content.png")

# Read each image
img1 <- image_read("Figures/Example_UTR5_boxplot_lengthAnalysis.png")
img2 <- image_read("Figures/Example_UTR5_GC_content.png")

# Append them horizontally
combined <- image_append(c(img1, img2), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_UTR5_features.png")

```

```{r gettingStartedenumeratePNGS, echo=FALSE, fig.wide = TRUE, fig.cap="Comparisons of 5'UTR length and GC content between mRNA belonging to regulated gene sets."}
knitr::include_graphics("Figures/combined_UTR5_features.png")

```

```{r gettingStartedhidePlots, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_boxplot_lengthAnalysis.pdf", "Example_UTR5_GC_content.pdf","Figures/Example_UTR5_boxplot_lengthAnalysis.png","Figures/Example_UTR5_GC_content.png"))
```

**Step 3:** Changes in translation efficiency are modeled using the `featureIntegration` function which performs stepwise regression to identify the collection of features that best explains the observed regulation. In this minimal example, a set of pre-calculated features is used including both *cis*-acting (enumerated mRNA features) and *trans*-acting (signatures of upstream regulatory pathways) factors. 

```{r gettingStartedFeatureInt, eval=TRUE, echo=TRUE}
# Prepare the list of pre-calculated features to be used in modelling (for example, the 'len' and 'content_UTR' variables defined in the previous step can be included) 
features <- postNetExample$features
str(features)

# Group the features according to category (optional)
group = c("UTR5", "UTR3", rep("UTR5",3), rep("UTR3",4), "CDS", "CDS", "UTR5", "UTR5", 
                rep("Pathway",2),"UTR5", rep("Pathway",2))
groupColour = c('#834b62','#6699cc','#e9724c','#fff275')
names(groupColour) <- c("UTR5","CDS", "UTR3","Pathway")

# Run feature integration modelling using stepwise regression
ptn <- featureIntegration(ptn = ptn, 
                          features = features, 
                          pdfName = "omnibus", 
                          regOnly = T, 
                          allFeat = F,
                          analysis_type = "lm",
                          covarFilt = 20,
                          comparisons = list(c(1,2)),
                          lmfeatGroup = group,
                          lmfeatGroupColour = groupColour,
                          NetModelSel = 'omnibus')

```

```{r gettingStartedFeatureIntPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
library(magick)
image_read_pdf("omnibus_lm_translationUp_translationDown_network.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/omnibus_lm_translationUp_translationDown_network.png")

image_read_pdf("omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.png")

```

```{r gettingStartedFeatureIntNetworkPNG, echo=FALSE, fig.cap="Network plot of the results of the stepwise regression omnibus model."}
knitr::include_graphics("Figures/omnibus_lm_translationUp_translationDown_network.png")

```

```{r gettingStartedhideFeatureIntPlots, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("omnibus_lm_translationUp_translationDown_Cockman_etal_2020_classicTOP_individually.pdf", "omnibus_lm_translationUp_translationDown_Down_individually.pdf","omnibus_lm_translationUp_translationDown_FinalModel.pdf","omnibus_lm_translationUp_translationDown_Gandin_etal_2016_mTOR_transUp_individually.pdf","omnibus_lm_translationUp_translationDown_Guan_etal_2017_Tg1_transUp_individually.pdf","omnibus_lm_translationUp_translationDown_network.pdf","omnibus_lm_translationUp_translationDown_uORFs_ATG_strong_individually.pdf","omnibus_lm_translationUp_translationDown_UTR3_C_individually.pdf","omnibus_lm_translationUp_translationDown_UTR3_T_individually.pdf","omnibus_lm_translationUp_translationDown_UTR3_T_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_A_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_length_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_T_individually.pdf"))
```

**Step 4:** The `plotFeaturesMap()` function is used to visualize the relationship between translation efficiency and different features that were identified in the modelling step as significantly contributing to the observed translational regulation. These visualizations are also useful for exploring the overlaps between different features within the same mRNAs.  

```{r gettingStartedPlotFeaturesMap, eval=TRUE, echo=TRUE}

ptn <- plotFeaturesMap(ptn,
                regOnly = TRUE,
                comparisons = list(c(1,2)),
                featSel = names(ptn_selectedFeatures(ptn, 
                                               analysis_type = "lm",
                                               comparison = 1)),
                remBinary = T,
                featCol = "UTR5_SCSCGS",
                scaled = F,
                remExtreme = 0.1,
                pdfName = 'Example')

```

```{r gettingStartedPlotFeaturesMapPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
library(magick)
image_read_pdf("Example_UTR5_SCSCGS_featureUMAP.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_SCSCGS_featureUMAP.png")

```

```{r gettingStartedPlotFeaturesMapPNG, echo=FALSE, fig.wide = TRUE, fig.cap="UMAP visualizing changes in translation efficiency (Effect) generated based on features identified in the omnibus model (left), with mRNAs containing SCSCGS motifs in the 5Â´UTR coloured (right)."}
knitr::include_graphics("Figures/Example_UTR5_SCSCGS_featureUMAP.png")

```

```{r gettingStartedhidePlotFeautresMaps, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_SCSCGS_featureUMAP.pdf"))
```

This example provided an overview of a minimal postNet workflow. Full details of alternative workflows and additional inputs and options are discussed in detail in the following sections. 

<a name="settingUp"/>

# Setting up a postNet analysis

The basic workflow of a postNet analysis aims to explain the post-transcriptional regulatory fate of mRNA based on their repertoire of *cis*-acting sequence features and/or interactions with *trans*-acting factors. Three basic inputs are required to run a postNet analysis:

1) Reference sequence annotations that will be used to identify and/or enumerate regulatory features.
2) Gene sets of interest that undergo post-transcriptional regulation.
3) A regulatory effect measurement, for example the log2 fold change in translation efficiency between an experimental and control condition.

These inputs are compiled at the start of the analysis by initializing a `postNetData` object using the `postNetStart()` function. This class of object serves as the container for storing inputs and some outputs generated during the analysis, and is designated by `ptn` in the example code provided here. The following sections describe the different options and customizations available, along with examples illustrating how to set up a postNet analysis.

Throughout this vignette, we will use example data provided with the package to illustrate the implementation of different analyses. These data are published in the study by Krokowski et al. [@Krokowski2022], where changes in translation efficiency were measured using ribosome profiling and RNA-seq in immortalized human corneal epithelial cells responding osmotic stress (500 mOsm, NaCl) for 1 h, along with controls. Genes that were translationally activated or suppressed under osmotic stress were identified using the anota2seq algorithm [ref].

## Initializing a postNetData object using custom gene lists

<a name="geneLists"/>

The most flexible implementation of postNet allows gene lists of interest and regulatory effect measurements to be supplied from custom sources. Here, the  `postNetStart()` function will be used with the `geneList`, `geneListcolours`, `customBg`, and `effectMeasure` parameters to initialize the `postNetData` object.    

Depending on the aim of the analysis, different inputs can be provided. In the case where the goal is simply to enumerate sequence features in genes of interest without statistical comparisons, `geneList` can be a single list of gene IDs with no background gene set. To perform statistical comparisons, one or more gene sets of interest must be provided, either with or without a custom background gene set (`customBg` parameter). Although optional, it is strongly recommended to carefully consider that the appropriate background is used. Typically, this would be all genes in the given data set passing expression and/or reproducibility thresholds. When providing custom gene lists, it is also required to specify colours (`geneListcolours` parameter) that will be used in visualizations generated at various steps of the analysis.

For each gene provided as part of a gene set of interest or background set, you must provide a regulatory effect measurement. As postNet is designed for examining post-transcriptional regulation, this would typically be the log2 fold changes in mRNA translation efficiency or expression between two conditions. However, other continuous numeric variables representing a change between two conditions could also be used, allowing a high degree of flexibility in potential applications. 

The example below illustrates the set-up of a postNet analysis allowing identification of mRNA features and statistical comparisons between sets of translationally activated and suppressed genes, as well as modelling and network analysis to identify features associated with changes in translational regulation and their interdependence.  

```{r postNetStartGeneList, eval=TRUE, echo=TRUE}

# Genes of interest should be provided in a named list.
 myGenes <- postNetExample$geneList
 str(myGenes)
 
# All gene IDs in the list should be present in the background.
 myBg <- postNetExample$background
 str(myBg)
 
# The regulation effect measurement must be named with the same gene IDs
# present in the background (or the gene list if no custom background is provided).
 myEffect <- postNetExample$effect
 str(myEffect)

```

```{r postNetStartGeneListInit, eval=TRUE, echo=TRUE, results = 'hide'}

# Initialize the postNetData object with custom gene lists:
 ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   selection = "random",
   setSeed = 123,
   source = "load", 
   species = "human"
 )

```

## Initializing a postNetData object using an Anota2seqDataSet object

<a name="anota2seq"/>

A `postNetData` object can also be constructed directly downstream of running an analysis using the [Anota2seq](https://bioconductor.org/packages/anota2seq) package to identify differentially translated genes. Here, the  `postNetStart()` function will be used with the `ads`, `regulation`, `contrast`, `regulationGen`, and `contrastSel` parameters to initialize the `postNetData` object.  
 
*Anota2seq* can be applied using data from both polysome and ribosome profiling techniques, and categorizes genes into three different regulatory modes: 
1) Abundance, where changes in mRNA levels can be explained by transcription or mRNA stability.
2) Translation, where polysome-association is altered without a change in total mRNA level (this mode is expected to alter protein levels).
3) Buffering/translational offsetting, where polysome-association is maintained while total mRNA level changes (this mode is not expected to alter protein levels).

An `Anota2seqDataSet` can be provided using the `ads` parameter of `postNetStart()`. The `regulation` parameter allows the user to select which sets of regulated genes identified using *anota2seq* will be used in statistical comparisons and downstream feature integration modelling and network analysis. In addition to the three regulatory modes listed above, where changes in both total and translated mRNA are taken into account, it is also possible to examine differences in total and translated mRNA independently. Gene sets can be selected from multiple contrasts in *anota2seq* specified with the `contrast` parameter (see the [anota2seq vignette](https://bioconductor.org/packages/release/bioc/vignettes/anota2seq/inst/doc/anota2seq.pdf) for more details).    

The regulatory effect measurement is taken directly from the `Anota2seqDataSet` object, and is specified by the `regulationGen` parameter. *Anto2seq* calculates sets of fold changes for each gene, in each regulatory mode. Although gene sets from all regulatory modes and contrasts can be selected for statistical comparisons, only one "general" regulatory effect measurement can be supplied (i.e., fold changes in translation efficiency, *or* buffering, etc.), so consideration should be given to downstream modelling where the mRNA features (and/or other input signatures) quantified in the gene sets specified by `regulation` will be used to explain changes in the regulatory effect measurement specified by `regulationGen`. Similarly to the gene sets, the regulatory effect measurement can be selected from any contrast from the *anota2seq* analysis using the `contrastSel` parameter.        

When an `Anota2seqDataSet` is supplied, the appropriate background gene set, and colours for each gene list will be automatically retrieved.  

The example below illustrates the set-up of a postNet analysis using the output of *anota2seq*, `ads`.  
```{r GetAds, eval=TRUE, echo=TRUE, results = 'hide'}

library(anota2seq)

# Initialize Anota2seqDataSet using example data (see anota2seq vignette for details)
 ads <- anota2seq::anota2seqDataSetFromMatrix(
    dataP = postNetExample$ads_data$dataP,
    dataT = postNetExample$ads_data$dataT,
    phenoVec = postNetExample$ads_data$phenoVec,
    batchVec = c(1, 2, 3, 4, 1, 2, 3, 4),
    dataType = "RNAseq",
    normalize = FALSE)
    
# Run an anota2seq analysis:
# Note that the quality control and residual outlier testing are not 
# performed to limit the running time of this example. For full details 
# on running an analysis please see the anota2seq vignette and help manual.
 ads <- anota2seqRun(ads,
    performQC = FALSE, 
    performROT = FALSE, 
    useProgBar = FALSE)
```

```{r GetAdsrm, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("ANOTA2SEQ_rvm_fit_for_all_contrasts_group.jpg"))
```

This postNet analysis will allow identification of mRNA features and comparison between translationally activated and suppressed genes, as well as buffered (total mRNA up and down) genes from contrast 1. Feature integration and network analysis will model the fold changes in translation efficiency from contrast 1. Note that in this example, if the buffering gene sets are included in modelling comparisons, the regulatory effect measurement values for these genes will be the fold changes in translation efficiency.   

```{r postNetStartAds, eval=TRUE, echo=TRUE, results = 'hide'}

# Initialize the postNetData object:
  ptn_withAds <- postNetStart(
      ads = ads,
      regulation = c("translationUp","translationDown","bufferingmRNAUp","bufferingmRNADown"),
      contrast = c(1,1,1,1),
      regulationGen = "translation",
      contrastSel = 1,
      selection = "random",
      setSeed = 123,   # ensures reproducibility of random isoform selection
      source = "load",
      species = "human"
    )
  
```

## Reference sequence annotations

Reference sequence annotations in postNet are divided according to different regions of mRNA molecules (5'UTR, CDS, and 3'UTR) to allow regions to be compared separately. The `source` parameter of the `postNetStart()` function allows the user to select from several in-built sequence annotations provided with the package, retrieve sequence annotations directly from the NCBI RefSeq database [@OLeary2016], or provide custom sequence annotations. Optionally, UTR sequences can also be adjusted if more precise sequences are available, for example those experimentally determined using approaches like CAGE, QuantSeq, or long-read sequencing, etc.

It is highly recommended to use reference sequence annotations that correspond to those that were used in generating the input gene lists. For example, if RNA sequencing reads were counted using Ensembl gene/transcript annotations, these may not always correspond well to the sequences defined by RefSeq annotations, even if identifiers have been converted to be compatible. When running `postNetStart()`, a warning message describing differences in gene identifiers between the input gene lists and the reference sequence annotations will be printed to the console. Minor differences may be acceptable depending on the application. However, larger differences may warrant either reprocessing of input data, or selecting a more compatible reference sequence annotation before proceeding with the analysis.

### Loading in-built reference sequence annotations

By default, `source = "load"` meaning `postNetStart()` will load one of the in-built reference sequence annotations provided with the package. This option is available when `species = "human"` or `"mouse"`, and several versions can be chosen from with the `version` parameter. All in-built annotations are based on different releases of NCBI RefSeq GRCh38 (human) and GCRm39 (mouse) genome assemblies and corresponding transcript annotations.     

It is possible to check which RefSeq release versions have in-built annotations available within the package using the `checkAvailableVersions()` function.

```{r RefSeqCheckVersions, eval=TRUE, echo=TRUE}

# List RefSeq release versions of available annotations in the package
checkAvailableVersions(species = "human")
checkAvailableVersions(species = "mouse")

```

A `postNetData` object can then be initialized using the in-built reference sequence annotations, in this case using the RefSeq ver_40.202408 release version for human. Note that if no version is specified, the latest release will be used.

```{r RefSeqLoad, eval=FALSE, echo=TRUE}

# Prepare custom gene lists and regulatory effect measurement using example data:
myGenes <- postNetExample$geneList
myBg <- postNetExample$background
myEffect <- postNetExample$effect

# Initialize a postNetData object using in-built annotations for human:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "load", 
   species = "human",
   version = "ver_40.202408"
 )

```

### Retrieving or constructing reference sequence annotations from the NCBI RefSeq database

In addition to the in-built annotations, it is also possible to either retrieve or construct reference sequences for any RefSeq release version. Currently, only human and mouse are supported with these options. 

By specifying `source = "create"` in `postNetStart()`, annotation files from the most recent RefSeq release version for the indicated species will be automatically downloaded and used to construct a new reference sequence annotation locally. Note that downloads may take several minutes, and files will be stored in the working directory. Using this option requires an internet connection.

```{r RefSeqCreate, eval=FALSE, echo=TRUE}

# Initialize a postNetData object creating new RefSeq reference sequence annotations for human:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "create", 
   species = "human",
 )

```

Alternatively, two additional off-line methods are available to construct reference sequence annotations if files have already been downloaded from [RefSeq](https://www.ncbi.nlm.nih.gov/refseq/) and are available locally. This can be done by specifying `source = "createFromSourceFiles"` in `postNetStart()`, and providing the the RNA GBFF ("rna.gbff"), RNA FASTA ("rna.fna"), and genomic GFF ("genomic.gff") files. These files must be provided using the `rna_gbff_file`, `rna_fa_file`, and `genomic_gff_file` parameters of `postNetStart()`.    

```{r RefSeqCreateFromSourceFiles, eval=FALSE, echo=TRUE}

#  The required RefSeq annotation files downloaded from the NCBI database will 
#  have the following naming:
#  - "example_rna.gbff.gz"
#  - "example_rna.fa.gz"
#  - "example_genomic.gff.gz"

# Initialize a postNetData object creating a new RefSeq reference sequence annotation 
# from source files:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "createFromSourceFiles",
   species = "human",
   rna_gbff_file = "example_rna.gbff.gz",
   rna_fa_file = "example_rna.fa.gz",
   genomic_gff_file = "example_genomic.gff.gz"
 )

```

For added flexibility in defining sequence regions, it is also possible to assemble reference sequence annotations from a FASTA file using `source = "createFromFasta"` in `postNetStart()`. This option requires that a FASTA file be provided using the `fastaFile` parameter, along with an additional file specifying the coordinates of the mRNA sequence regions (provided with the `posFile` parameter). This position file must tab delimited and have columns indicating the transcript id, 5'UTR length, end of the coding sequence, and the total transcript length (see example below). Optionally, a genomic GFF file can also be provided using the `genomic_gff_file` parameter, however, if not GFF is provided the latest version for the indicated species will be automatically downloaded from the RefSeq database.  

```{r RefSeqCreateFromFasta, eval=FALSE, echo=TRUE}

# An example of the required format for the posFile parameter ("positions.txt"):
# id	UTR5_len	cds_stop	total_length
# NM_000014	70	4495	4610
# NM_000015	70	943	1285
# NM_000016	79	1345	2261

# Initialize a postNetData object creating a new RefSeq reference sequence annotation 
# from source files:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "createFromFasta",
   species = "human",
   fasta_file = "_rna.fa.gz",
   posFile  = "positions.txt"
   genomic_gff_file = "_genomic.gff.gz"
 )

```

### Using custom reference sequence annotations

The transcriptome is highly diverse, with mRNA isoform expression patterns varying across cell types [ref], and between normal and disease states [ref]. The sequences of mRNA molecules can also be dynamically regulated through processes such as alternative splicing [ref], altered transcription start site usage [ref], and alternative polyadenylation [ref]. Analyses relating mRNA sequence features to post-transcriptional regulation will benefit from more precise sequence annotations if these are available.

Custom reference sequence annotations can be used with the `postNetStart()` function and may be desirable in cases when working with data from species not currently supported by the options described above, with annotations other than those in the NCBI RefSeq database, or if sequences have been experimentally determined. A pre-prepared reference sequence annotation file can be provided using the `customFile` parameter. This file must be tab delimited and contain the columns: transcriptID, geneID, UTR5_seq, CDS_seq, and UTR3_seq. 

```{r RefSeqCustom, eval=FALSE, echo=TRUE}

# An example of the required format for the customFile parameter ("customSequences.txt"):
# id	geneID	UTR5_seq	CDS_seq	UTR3_seq
# NM_000014	A2M	GGGACCAG...	ATGGGGAA...	AGACCACA...

# Initialize a postNetData object with a custom reference sequence annotation file:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "custom",
   species = NULL,
   customFile = "customSequences.txt"
 )

```

### Selecting transcript isoforms

Using sequence annotations provided with the package or built from the RefSeq database, postNet will perform gene-level analyses. For genes with multiple mRNA isoforms, the `selection` parameter of the `postNetStart()` function can be used to specify which isoforms will be considered in analyses. Depending on the application, it may sometimes be of interest to consider the longest or shortest mRNA isoforms for each gene. However, selecting the extremes for all genes may skew the results for some types of analysis. By default, isoforms for each gene will be selected at random to prevent a systematic length bias. However, it is important to note that each time the `postNetStart()` function is run, different isoforms may be selected leading to slight variations in results. To ensure reproducibility of isoform selection between different runs of the `postNetStart()` function, it is necessary to use the `setSeed` parameter.  

It is also possible to perform transcript-level analyses with postNet by supplying custom sequence annotations as described above (I guess the featureIntegration using isoform-level data might suffer from the same issue as anota2seq due to correlations between isoforms of the same genes? Should probably mention this somewhere).

```{r IsoformSel, eval=FALSE, echo=TRUE}

# Initialize a postNetData object with random, reproducible mRNA isoform selection:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "load",
   species = "human",
   selection = "random",
   setSeed = 123
 )

```
 
### Adjusting UTR sequence annotations

Numerous sequencing approaches are available to specifically map UTRs, such as CAGE/nanoCAGE [ref] and QuantSeq [ref]. For this reason, it is also possible to adjust only UTR sequences if more specific data is available for your experimental condition or model of interest.

Custom UTR sequences will replace UTRs in an existing annotation file when using the `adjObj` and `region_adj` parameters of the `postNetStart()` function. A list of custom sequences must be provided, specifying which UTR region(s) should be replaced. If custom UTR sequences are available for some, but not all genes in the existing sequence annotation, whether genes and isoforms without custom sequences are kept or discarded from the analysis can by controlled using the `excl` parameter. The `keepAll` parameter can also be used to control how custom UTR isoform sequences are stored for genes with multiple isoforms.        

```{r AdjObj, eval=TRUE, echo=TRUE}

# Create the adjObj list with custom 5'UTR sequences to replace those in the loaded annotation file
myUTR5seqs <- ptn_sequences(ptn, "UTR5")
myIDd <- ptn_id(ptn, "UTR5")
names(myUTR5seqs) <- myIDd
customUTR5s <-  list(UTR5 = myUTR5seqs)
str(customUTR5s)

```
 
```{r AdjustUTRs, eval=FALSE, echo=TRUE}

# Initialize a postNetData object with custom 5'UTR sequences, replacing the 5'UTR sequences
# in the loaded annotation file with custom ones where available, and discarding all isoforms 
# without custom sequences. Genes with no custom sequence will retain all isoforms from the original annotation:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "load",
   species = "human",
   selection = "random",
   setSeed = 123,
   adjObj = customUTR5s,
   region_adj = "UTR5",
   excl = FALSE,
   keepAll = FALSE
 )

```
 
 
<a name="mRNAfeatures"/>

# Analysis of mRNA sequence features

*PostNet* includes a variety of tools for identifying and enumerating sequence features of mRNA. These tools can be used for stand-alone analyses to visualize and perform statistical comparisons of mRNA features between sets of regulated genes (described below). However, the outputs of these tools can also be compiled into per-gene catalogs of *cis*-acting regulatory features and used with the `featureIntegration()` function to model changes in post-transcriptional regulation, and dissect networks of interactions between features.

## Statistical comparisons, selecting sequence sub-regions, and plotting options

<a name="comparisons"/>

For the tools described in the following sections, where possible, statistical analyses are performed by providing the `comparisons` parameter, where the input is a list of numeric vectors specifying the pairwise comparisons to be made between gene sets defined by `geneList` (if using custom inputs), or `regulation` (if using the results of an *anota2seq* analysis) parameters in the `postNetStart()` function. Comparisons can be made between gene sets of interest, and between gene sets and the background set, which is always denoted by 0. For example, `list(c(1,2), c(0,1), c(0,2))` would produce three sets of statistics for the comparisons between gene sets 1 and 2, and each for against the background set. Unless otherwise described, significant differences in enumerated mRNA features between pairs of gene sets are evaluated using two-sided Wilcoxon rank sum tests.

<a name="subregions"/>

Some regulatory sequence features of mRNA are highly positional, such as 5'terminal oligopyrimidine (TOP) motifs [ref], or codon "ramp" sequences [ref]. Therefore, for some tools described below, users may wish to search for and/or enumerate mRNA sequence features within more specific sequence sub-regions. This can be accomplished using the `subregion`, and `subregionSel` parameters. The `subregion` parameter takes an integer indicating the number of nucleotides to include or exclude from either the start of the sequence region if positive, or the end if negative. For example, `subregion = 50` denotes the first 50 nucleotides of the sequence region(s) specified by the `region` parameter (5'UTR, CDS, or 3'UTR), while `subregion = -50`, denotes the last 50 nucleotides of the sequence region(s). A logical is then supplied to `subregionSel`, allowing the user to either examine only this selected sub-region, or to exclude it from the analysis. 

<a name="plottingOpts"/>

In most cases, three options for visualizations are available with the `plotType` parameter, including box plots, violin plots, and empirical cumulative distribution functions (eCDFs). If the `plotType` selected is *ecdf*, then differences between distributions at the 25th, 50th, and 75th percentiles will also be reported.     

## Length of sequence regions

The length of different mRNA sequence regions can have important implications for post-transcriptional regulation [ref]. For each gene, the `lengthAnalysis()` function computes and returns a list of the log2 length of each mRNA sequence region specified by the `region` parameter. [Statistical comparisons](#comparisons) and [visualizations](#plottingOpts) can be generated using the parameters described above.

The example below will compute a list (`len`) of the log2 length for each gene and sequence region, and produce three PDF files with eCDFs and statistics comparing the length of each sequence region between gene sets and background.   
```{r lengthAnalysisBoxplot, eval=TRUE, echo=TRUE}

# Calculate the length of the 5'UTR, 3'UTR and coding sequence for each gene, and compare lengths between
# translationUp genes vs. background, translationDown genes vs. background, and translationUp vs. 
# translationDown genes
 len <- lengthAnalysis(ptn = ptn, 
                      region = c("UTR5","CDS","UTR3"), 
                      comparisons = list(c(0,1),c(0,2),c(1,2)),
                      plotOut = TRUE,
                      plotType = 'ecdf',
                      pdfName = "Example")
                      
 str(len)

```

```{r lengthAnalysisPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("Example_UTR5_ecdf_lengthAnalysis.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_ecdf_lengthAnalysis.png")

image_read_pdf("Example_UTR3_ecdf_lengthAnalysis.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR3_ecdf_lengthAnalysis.png")

image_read_pdf("Example_CDS_ecdf_lengthAnalysis.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_CDS_ecdf_lengthAnalysis.png")

# Read each image
img1 <- image_read("Figures/Example_UTR5_ecdf_lengthAnalysis.png")
img2 <- image_read("Figures/Example_UTR3_ecdf_lengthAnalysis.png")
img3 <- image_read("Figures/Example_CDS_ecdf_lengthAnalysis.png")

# Append them horizontally
combined <- image_append(c(img1, img2, img3), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_length.png")


```

```{r lengthAnalysisPNG, echo=FALSE, fig.wide = TRUE, fig.cap="eCDFs visualizing differences in Log2(Length) of mRNA sequence regions between different gene sets. 5'UTR (right), 3'UTR (middle), CDS (left). Statistical comparisons are made between translationally activated (blue), suppressed (red), and background (grey) gene sets. Visualizations can be also generated as either box plots, or violin plots"}
knitr::include_graphics("Figures/combined_length.png")

```

```{r lengthAnalysisHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_ecdf_lengthAnalysis.pdf", "Example_UTR3_ecdf_lengthAnalysis.pdf", "Example_CDS_ecdf_lengthAnalysis.pdf",
         "Figures/Example_UTR5_ecdf_lengthAnalysis.png", "Figures/Example_UTR3_ecdf_lengthAnalysis.png",
         "Figures/Example_CDS_ecdf_lengthAnalysis.png"))
```

## Nucleotide content

Nucleotide content is strongly associated with the post-transcriptional fate of mRNAs [ref]. For each gene, the `contentAnalysis()` function computes and returns a list of the percentage of nucleotide content of each mRNA sequence region specified by the `region` parameter. It is also possible to select more specific sequence [sub-regions](#subregions) to either examine or exclude from the analysis. [Statistical comparisons](#comparisons) and [visualizations](#plottingOpts) can be generated using the parameters described above.

The `contentIn` parameter is used to specify one or more nucleotide(s) or nucleotide combinations to quantify. These can be any selection or combination of A, T, G, or C. For example `c("GC")` to obtain the combined percentage of G and C, or `c("G", "C")` to obtain the individual percentages. Within the coding sequence, it may also of interest to calculate nulceotide content at specific codon positions, for example the GC content at the 3rd codon position ("GC3") is often used as an indicator of codon bias [ref]. For this reason, when the input for the `region` parameter includes `"CDS"`, nucleotide content at specific codon positions can also be quantified by supplying the nucleotide or combination of nucleotides, along with the codon position to be examined (1, 2, or 3). For example, `c("GC3")` calculates percentage of GC content in the third codon position, while `c("A12")` would provide the percentage of A content in the first and second codon positions.   

The example below will compute a list (`GC_content`) of the percentage of GC content for each gene and sequence region, and produce three PDF files with violin plots and statistics comparing the GC content of each sequence region between gene sets and background.   
```{r contentAnalysisGCviolin, eval=TRUE, echo=TRUE}

# Calculate the GC of each sequence region for each gene, and compare between
# translationUp genes vs. background, translationDown genes vs. background, and 
# translationUp vs. translationDown genes
 GC_content <- contentAnalysis(ptn = ptn, 
                           region = c("UTR5","CDS","UTR3"),
                           comparisons = list(c(0,1),c(0,2),c(1,2)), 
                           contentIn = c("GC"),
                           plotOut = TRUE,
                           plotType = "violin",
                           pdfName = "Example")
                      
 str(GC_content)

```

```{r contentAnalysisPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("Example_UTR5_GC_content.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_GC_content.png")

image_read_pdf("Example_UTR3_GC_content.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR3_GC_content.png")

image_read_pdf("Example_CDS_GC_content.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_CDS_GC_content.png")

# Read each image
img1 <- image_read("Figures/Example_UTR5_GC_content.png")
img2 <- image_read("Figures/Example_UTR3_GC_content.png")
img3 <- image_read("Figures/Example_CDS_GC_content.png")

# Append them horizontally
combined <- image_append(c(img1, img2, img3), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_GC.png")


```

```{r contentAnalysisPNG, echo=FALSE, fig.wide = TRUE, fig.cap="Violin plots visualizing differences in the percentage of GC content of mRNA sequence regions between different gene sets. 5'UTR (right), 3'UTR (middle), CDS (left). Statistical comparisons are made between translationally activated (blue), suppressed (red), and background (grey) gene sets. Visualizations can be also generated as either box plots, or eCDFs"}
knitr::include_graphics("Figures/combined_GC.png")

```

```{r contentAnalysisHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_GC_content.pdf", "Example_UTR3_GC_content.pdf", "Example_CDS_GC_content.pdf",
         "Figures/Example_UTR5_GC_content.png", "Figures/Example_UTR3_GC_content.png",
         "Figures/Example_CDS_GC_content.png"))
```

In addition to calculating the percentage of GC content for each gene and sequence region, the code below will also return the GC content at the third codon position (GC3) for the coding sequence.  
```{r contentAnalysisGC3, eval=FALSE, echo=TRUE}

# Calculate the GC of each sequence region for each gene, as well as the GC3 content of
# the coding region and compare between translationUp genes vs. background, translationDown 
# genes vs. background, and translationUp vs. translationDown genes
 GC_GC3_content <- contentAnalysis(ptn = ptn, 
                           region = c("UTR5","CDS","UTR3"),
                           comparisons = list(c(0,1),c(0,2),c(1,2)), 
                           contentIn = c("GC","GC3"),
                           plotOut = TRUE,
                           plotType = "violin",
                           pdfName = "Example_GC_GC3")
                      
```

Finally, the code below provides and example of how the `subregion` and `subregionSel` parameters can be used to quantify the percentage of G content in the first and last 15 nucleotides of the 5'UTR 
```{r contentAnalysisSubregion, eval=FALSE, echo=TRUE}

# Calculate the G content of the first and last 15 nucleotides of the 5'UTR for each gene, and 
# compare between translationUp genes vs. background, translationDown genes vs. background, and 
# translationUp vs. translationDown genes
 content_UTR5_first15 <- contentAnalysis(ptn = ptn, 
                           region = c("UTR5"),
                           subregion = 15,
                           subregionSel = "select",
                           comparisons = list(c(0,1),c(0,2),c(1,2)), 
                           contentIn = c("G"),
                           plotOut = TRUE,
                           plotType = "ecdf",
                           pdfName = "Example_First15utr5")

content_UTR5_last15 <- contentAnalysis(ptn = ptn, 
                           region = c("UTR5"),
                           subregion = -15,
                           subregionSel = "select",
                           comparisons = list(c(0,1),c(0,2),c(1,2)), 
                           contentIn = c("G"),
                           plotOut = TRUE,
                           plotType = "ecdf",
                           pdfName = "Example_Last15utr5")
                      
```

## Folding energy

The folding energy of mRNA molecules is an indication of the thermodynamic stability of higher-order structures, and has implications for post-transcriptional regulation, including impacts on translation efficiency, co-translational protein folding, and mRNA stability and localization [refs]. For each gene, the `foldingEnergyAnalysis()` function returns a list of free energy measurements for each mRNA sequence region specified by the `region` parameter. [Statistical comparisons](#comparisons) and [visualizations](#plottingOpts) can be generated using the parameters described above.

The `foldingEnergyAnalysis()` function does not perform folding energy calculations for sequences, but allows comparisons between gene sets of interest using pre-calculated values. The source of these values is specified using the `sourceFE` parameter, where pre-calculated values provided with the package can either be loaded, or custom values can be supplied using the `customFileFE` parameter. Pre-calculated folding energies supplied with the package are currently available for human and mouse RefSeq releases "rel_109.20201120", and "rel_109.20200923". These values were calculated for all sequence regions using the mfold algorithm [@Zuker2003], available [here](https://www.unafold.org/). Mfold reports the Gibbs free energy (Î*G*) for the most probable RNA structures, where lower values indicate more stable structures and larger ones indicate less stable, more flexible mRNA molecules.  

To use custom free energy values with the `customFileFE` parameter, the user must supply a TAB delimited file with three columns corresponding to: transcript ID, folding energy, and length of the sequence region. Note that folding energies for different sequence regions (e.g. 5'UTR and 3'UTR) must be provided separately.

The `residFE` parameter also offers the option of correcting the the folding energies for the length of the sequences, which may sometimes be desirable to facilitate comparisons between gene sets. Here, instead of Î*G*, the values returned are the residuals from the linear model: FE ~ log2(sequence region length). Note that if folding energies will be used in downstream modelling analysis with `featureIntegration()`, consideration should be given to the `residFE` parameter. If the length of the sequence regions will also be included in modelling, it is not recommended to correct the folding energies for the sequence length.

The example below will compute a list (`FE`) of the folding energies for each gene and sequence region, and produce three PDF files with violin plots and statistics comparing the folding energy of each sequence region between gene sets and background. 
```{r foldingEnergyBoxplot, eval=TRUE, echo=TRUE}

# Compare the folding energy of the 5'UTR, 3'UTR and CDS for each gene between translationUp 
# genes vs. background, translationDown genes vs. background, and translationUp vs. translationDown genes. 
 FE <- foldingEnergyAnalysis(ptn = ptn,
                               region=c("UTR5","CDS","UTR3"),
                               comparisons = list(c(0,1),c(0,2),c(1,2)),
                               residFE = FALSE, 
                               plotType = "boxplot",
                               sourceFE = "load",
                               plotOut = TRUE,
                               pdfName = "Example")
 str(FE)
```

```{r foldingEnergyPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("Example_UTR5_boxplot_foldEnergyAnalysis.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_boxplot_foldEnergyAnalysis.png")

image_read_pdf("Example_UTR3_boxplot_foldEnergyAnalysis.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR3_boxplot_foldEnergyAnalysis.png")

image_read_pdf("Example_CDS_boxplot_foldEnergyAnalysis.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_CDS_boxplot_foldEnergyAnalysis.png")

# Read each image
img1 <- image_read("Figures/Example_UTR5_boxplot_foldEnergyAnalysis.png")
img2 <- image_read("Figures/Example_UTR3_boxplot_foldEnergyAnalysis.png")
img3 <- image_read("Figures/Example_CDS_boxplot_foldEnergyAnalysis.png")

# Append them horizontally
combined <- image_append(c(img1, img2, img3), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_FE.png")


```

```{r foldingEnergyPNG, echo=FALSE, fig.wide = TRUE, fig.cap="Box plots visualizing differences in the folding energy of mRNA sequence regions between different gene sets. 5'UTR (right), 3'UTR (middle), CDS (left). Statistical comparisons are made between translationally activated (blue), suppressed (red), and background (grey) gene sets. Visualizations can be also generated as either violin plots, or eCDFs"}
knitr::include_graphics("Figures/combined_FE.png")

```

```{r foldingEnergyHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_boxplot_foldEnergyAnalysis.pdf", "Example_UTR3_boxplot_foldEnergyAnalysis.pdf", "Example_CDS_boxplot_foldEnergyAnalysis.pdf",
         "Figures/Example_UTR5_boxplot_foldEnergyAnalysis.png", "Figures/Example_UTR3_boxplot_foldEnergyAnalysis.png",
         "Figures/Example_CDS_boxplot_foldEnergyAnalysis.png"))
```

In the example code below, a custom file with pre-calculated folding energies is provided for 5'UTR sequences.
```{r foldingEnergyCustom, eval=FALSE, echo=TRUE}

# An example of the required format for the customFile parameter ("custom_UTR5FE.txt"):
# id	fold_energy	length
# NM_018117	-16.3	34
# NM_001025603	-36.84	162
# NM_001003891	-28.4	81
# NM_021107	-120.14	350

# Compare the folding energy of the 5'UTR for each gene between translationUp genes vs. background, 
# translationDown genes vs. background, and translationUp vs. translationDown genes. 
 customFE <- foldingEnergyAnalysis(ptn = ptn,
                               region = c("UTR5"),
                               comparisons = list(c(0,1),c(0,2),c(1,2)),
                               residFE = FALSE, 
                               plotType = 'violin',
                               sourceFE = "custom",
                               customFileFE = "~/Path/To/CustomFile/custom_UTR5FE.txt",
                               plotOut = TRUE,
                               pdfName = 'Example_customFE')
 
```

## Upstream open reading frames

Upstream open reading frames (uORFs) are common regulatory elements found in the 5'UTRs of many transcripts, imparting context-dependent post-transcriptional regulatory effects [ref]. For each gene, the `uorfAnalysis()` function returns either the number, or the coordinates of the positions of uORFs in the 5'UTR. [Statistical comparisons](#comparisons) can be generated using the parameters described above. 

By default, the `uorfAnalysis()` function will search for uORFs with canonical start codons ("AUG") in a strong Kozak context. However, it is also possible to identify uORFs with non-canonical start codons using the `startCodon` parameter, and to specify the Kozak context of the using the `KozakContext` parameter, where:

1) `"strong"` = [AG][ATGC][ATGC] [Start codon] G
2) `"adequate1"` = [AG][ATGC][ATGC] [Start codon] [ATC]
3) `"adequate2"` = [TC][ATGC][ATGC] [Start codon] G
4) `"weak"` = [TC][ATGC][ATGC] [Start codon] [ATC]
5) `"any"` = [ATGC][ATGC][ATGC [Start codon] [ATGC]

Note that if `KozakContext = "any"`, the nucleotide context of the start codon is not considered. 

Some uORFs are completely contained within the 5'UTR, as is the case for the uORF found in the transcript CHOP (DDIT3). However, in other cases the start codon for the uORF may be in the 5'UTR, but the stop codon may be found downstream of the start codon of the main ORF, as for ATF4 [ref]. Using the `onlyUTR5` parameter, it is possible to specifically identify uORFs completely contained in 5'UTRs, instead of all uORFs. 

Finally, in addition to quantifying the number of uORFs for a given transcript, it is also often of interest to know the positions in the sequence where the uORFs occur. The `unitOut` parameter can be used to specify whether the number, or coordinates (nucleotide position of the start and stop codons) of the detected uORFs will be returned. 

The example below will compute a list (`uORFs`) of the number of uORFs with canonical start codons in a strong Kozak context for each gene, and produce a PDF file with a bar plot and statistics comparing between gene sets.   
```{r uorfAnalysis, eval=TRUE, echo=TRUE}

# Identify all uORFs with canonical start codons in a strong Kozak context (including
# those not fully contained within 5'UTRs, and compare between translationUp vs. translationDown genes

 uORFs <- uorfAnalysis(ptn = ptn,
                      comparisons = list(c(1,2)),
                      startCodon = "ATG",
                      KozakContext = c("strong"),
                      onlyUTR5 = FALSE,
                      unitOut = "number",
                      plotOut = TRUE,
                      pdfName = 'Example')
                      
 str(uORFs)
```

```{r uorfAnalysisPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("Example_uORFs_strong.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_uORFs_strong.png")

```

```{r uorfAnalysisPNG, echo=FALSE, fig.wide = TRUE, fig.cap="Bar plot visualizing differences in the proportion of transcripts containing uORFs with canonical start codons in a strong Kozak context between different gene sets. Statistical comparisons are made between translationally activated (blue), and suppressed (red) gene sets."}
knitr::include_graphics("Figures/Example_uORFs_strong.png")

```

```{r fuorfAnalysisHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_uORFs_strong.pdf"))
```

## Motif discovery using STREME

*De novo* motif discovery in postNet is carried out using the `motifAnalysis()` function, which implements [STREME](https://meme-suite.org/meme/doc/streme.html) [@Bailey2021] from the [MEME-Suite](https://meme-suite.org/) [@Bailey2015] to identify ungapped motifs (recurring, fixed-length patterns) that are enriched in the selected sequence region(s) of gene sets of interest relative to control sequences (background). It is also possible to select more specific sequence [sub-regions](#subregions) to either examine or exclude from the analysis.

The `motifAnalysis()` function applies `runStreme()` from the [memes package](https://bioconductor.org/packages/release/bioc/html/memes.html) [@Nystrom2021]. This requires that the MEME Suite software tools be installed locally, and the path to the executables must be provided (`memePath` parameter). The MEME Suite can be downloaded [here](https://meme-suite.org/meme/doc/download.html) following the [installation guide](https://meme-suite.org/meme/doc/install.html?man_type=web). It is possible to specify the minimum width (in nucleotides) and the enrichment p-value threshold for selecting motifs using the `minwidth` and `stremeThreshold` parameters. If custom reference sequence annotations have been used, the sequence type (RNA, DNA, protein) can also be adjusted with the `seqType` parameter. It is important to note that when using postNet with a custom [gene list](#geneLists), if no background is provided, postNet defines the background as all genes in the gene list. In the scenario where only one gene set is provided in the list, it is not advisable to use `motifAnalysis()` to identify enriched motifs, as the input and background will be the same.     

The `motifAnalysis()` function returns an updated `postNetData` object where results are stored in the "motifs" slot. Identified motifs can be enumerated in transcripts and included in downstream modelling with `featureIntegration()` by using the `contentMotifs()` function. All results, including the list of significantly enriched motifs can be extracted using the `ptn_motifSelection()` and `ptn_motifgeneList()` functions.   

**Note**: If you use `motifAnalysis()` in your work, please appropriately cite the memes R package, The MEME Suite, and the STREME tool. Licensing The MEME Suite is free for non-profit use. However, for-profit users should contact OIC-MEMESuite@ucsd.edu and purchase a license. See http://meme-suite.org/doc/copyright.html for details

In the example below, *de novo* motifs enriched in translationally activated and suppressed gene sets compared to background will be identified for all sequence regions. Motifs passing an enrichment p-value threshold of 0.05 will be extracted, along with the full motif analysis results for the translationally activated gene set.
```{r motifAnalysis, eval=FALSE, echo=TRUE}

# Note that as users must provide the path to the MEME Suite executables. An example of
# how to run this function is provided below, and can be updated with the correct memePath argument. 

 ptn <- motifAnalysis(ptn = ptn, 
                     stremeThreshold = 0.05,
                     minwidth = 6,
                     memePath = "/meme/bin", 
                     region = c('UTR5','CDS','UTR3'))

# Extract the significantly enriched motifs:
 denovo_UTR5motifs <- ptn_motifSelection(ptn = ptn,
                                region = 'UTR5')
                                
# Extract full motif results from one gene set of interest:                                
 denovo_UTR5motifs_TransUp <- ptn_motifSelection(ptn = ptn,
                                      region = 'UTR5',
                                      geneList = 'translationUp')
                                
```

## Motif enumeration

Sequence motifs can contribute to the structure and stability of RNA molecules, as well as mediate RNA-protein interactions [ref]. Numerous motifs play an important role in post-transcriptional regulation, including 5'TOP motifs, which render translation sensitive to regulation via mTOR [ref], and G-quadruplexes that can impact the translation and stability of the mRNAs where they occur [ref]. For each gene, the `contentMotifs()` function identifies user-supplied sequence motifs and returns a list of enumerations and/or positions for each mRNA sequence region specified by the `region` parameter. It is also possible to select more specific sequence [sub-regions](#subregions) to either examine or exclude from the analysis. [Statistical comparisons](#comparisons) between gene sets can be specified using the parameters described above.

The `motifsIn` parameter is used to provide the motif sequences to be detected and enumerated. Ambiguities can be specified using [IUPAC codes](https://genome.ucsc.edu/goldenPath/help/iupac.html) or [ ] (bracket) annotations. The input motifs provided should match the type of reference sequences to be searched in your analysis (i.e., RNA, DNA, or protein), and be can specified using the `seqType` parameter. The `contentMotifs()` function can also implement [pqsfinder](https://bioconductor.org/packages/release/bioc/html/pqsfinder.html) to identify G-quadruplexes when `motifsIn = "G4"`, using the `min_score` to adjust the prediction threshold. If you use the "G4" option in your work, please cite Hon *et al*. [@Hon2017]. The [ATtRACT](https://attract.cnic.es/#) database, is a database of RNA binding proteins and associated motifs [@Giudice2016], and may also be useful for identifying motifs of interest and potential mechanisms of post-transcriptional regulation in your data. 

It is also possible to identify overlapping, or non-overlapping motifs, as well as dictate spatial constraints between motifs using the `dist` parameter to dictate the minimum nucleotide distance between motifs. Similarly to `uorfAnalysis()`, it is also often of interest to know the positions in the sequence where the motifs occur, and the `unitOut` parameter can be used to specify whether the number, or coordinates (nucleotide position of the beginning and end of the motif) will be returned. 

As for `foldingEnergyAnalysis()` the `resid` parameter of `contentMotifs()` offers the option of correcting the the number of motifs per transcript for the length of the sequences (as longer sequences have more opportunity to contain motifs). Here, the values returned are the residuals from the linear model: number of motifs ~ log2(sequence region length). Note that if motifs will be used in downstream modelling analysis with `featureIntegration()`, and the length of the sequence regions will also be included in the same models, it is not recommended to correct the number of motifs for the sequence length.

It is important to note that the `contentMotifs()` function uses a more strict method of sequence matching to count motifs than the MEME-Suite [@Bailey2015], and for this reason some motifs identified with `motifAnalysis()`, which implements STREME [@Bailey2021], may have divergent quantification between methods. Using a more stringent threshold with the `stremeThreshold` parameter of `motifAnalysis()` may remedy this. Alternatively, motifs identified with STREME can be counted using the [FIMO](https://meme-suite.org/meme/doc/fimo.html) [@Grant2011] tool provided with the MEME-Suite.

The example below will compute a list (`UTR5_SCSCGS_num`) of the number of SCSCGS in the 5'UTR for each gene, and produce a PDF file with an eCDF plot and statistics comparing enrichment of the motif between gene sets. A second list (`UTR5_SCSCGS_pos`) will contain the coordinates of the positions of the motifs within the 5'UTR for each gene.    
```{r contentMotifs, eval=TRUE, echo=TRUE}

# Detect and quantify a given motif within 5'UTRs, and compare between translationUp vs. 
# translationDown genes

UTR5_SCSCGS_num <- contentMotifs(ptn = ptn, 
                        motifsIn = "SCSCGS",
                        region = c("UTR5"), 
                        comparisons = list(c(1,2)),
                        dist = 1,
                        unitOut = "number",
                        pdfName = "Example",
                        plotOut = TRUE)
                      
 str(UTR5_SCSCGS_num)
 
 # Now find the coordinates of positions where the motif occurs in 5'UTRs
 
 UTR5_SCSCGS_pos <- contentMotifs(ptn = ptn, 
                        motifsIn = "SCSCGS",
                        region = c("UTR5"), 
                        comparisons = list(c(1,2)),
                        dist = 1,
                        unitOut = "position")
 
 str(UTR5_SCSCGS_pos$UTR5_SCSCGS[1:3])
 
```

```{r contentMotifsPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("Example_UTR5_SCSCGS_content.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_SCSCGS_content.png")

```

```{r contentMotifsPNG, echo=FALSE, fig.wide = TRUE, fig.cap="eCDFs visualizing differences in the presence of the SCSCGS motif in the 5'UTR of different gene sets. Statistical comparisons are made between translationally activated (blue) and suppressed (red) gene sets. Background genes are shown in grey."}
knitr::include_graphics("Figures/Example_UTR5_SCSCGS_content.png")

```

```{r contentMotifsHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_SCSCGS_content.pdf"))
```

## Codon and amino acid usage

PostNet includes functionality for enumerating and comparing codon usage across gene sets, implemented with the `codonUsage()`, and `codonCalc()` functions. In this workflow, the `codonUsage()` function is first used to enumerate usage of single codons (or multiple, e.g. dicodons) or amino acids (AAs), and identify those that are enriched or depleted between different gene sets of interest. The `codonCalc()` function can then be applied to obtain the number or frequency of selected codons or AAs for each gene, and perform statistical comparisons between gene sets. The outputs of `codonCalc()` can be used as input features for modelling analyses using `featureIntegration()`. 

### Generating a codon and amino acid count and frequency table 

The `codonUsage()` function can be used to enumerate either codon or AA usage, specified with the `analysis` parameter. Analyses can be performed using the coding region of reference sequence annotations stored in the `postNetData` object. Alternatively, coding sequences can be either automatically created from the [NCBI Consensus CDS database](https://www.ncbi.nlm.nih.gov/projects/CCDS/CcdsBrowse.cgi) or loaded using the `annotType` and `sourceSeq`parameters. It is also possible to enumerate multiple codon combinations, for example dicodons, using the `codonN` parameter. Similarly to `contentAnalysis()` and `contentMotifs()`, it is also possible to select more specific sequence [sub-regions](#subregions) for analysis, for example to specifically examine the codon "ramp" immediately downstream of the start codon [ref].  

The example below demonstrates an implementation of `codonUsage()` generating a summary table of codon counts and frequencies for all genes. Note that "frequency" corresponds to the number of codons relative to all codons in the gene, while "relative frequency" corresponds to the number of codons relative to all synonymous codons in the gene. This table can then be retrieved using the `ptn_codonAnalysis()` function. In this case, [statistical comparisons](#comparisons) will be performed between translationally activated and suppressed gene sets. 
```{r codonUsageTable, eval=TRUE, echo=TRUE}
# Examine the composition of all genes:

 ptn <- codonUsage(ptn = ptn, 
          annotType = "ptnCDS", 
          sourceSeq = "load", 
          analysis = "codon", 
          codonN = 1,
          comparisons = list(c(1,2)))

# Retrieve the codon usage summary table                     
 codonUsageTable <- ptn_codonAnalysis(ptn)
 str(codonUsageTable)
 
```

In addition to the summary table, the example code above also generates plots comparing the average codon usage and frequency between the gene sets of interest specified by the `comparisons` parameter.

```{r codonUsagePlotsPDF, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("codon_translationUp_translationDown_codonUsage.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/codon_translationUp_translationDown_codonUsage.png")

image_read_pdf("codon_translationUp_translationDown_averageFreq.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/codon_translationUp_translationDown_averageFreq.png")

# Read each image
img1 <- image_read("Figures/codon_translationUp_translationDown_codonUsage.png")
img2 <- image_read("Figures/codon_translationUp_translationDown_averageFreq.png")

# Append them horizontally
combined <- image_append(c(img1, img2), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_codon_plots.png")

```

```{r codonUsagePlotsPNG, echo=FALSE, fig.wide = TRUE, fig.cap="Scatter plots comparing average codon usage and frequency between gene sets of interest. Codons encoding the same amino acid are coloured and connected by lines."}
knitr::include_graphics("Figures/combined_codon_plots.png")

```

```{r codonUsagePlotsHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("codon_translationUp_translationDown_codonUsage.pdf", "codon_translationUp_translationDown_averageFreq.pdf",
         "Figures/codon_translationUp_translationDown_codonUsage.png", "Figures/codon_translationUp_translationDown_averageFreq.png"))
```

### Codon usage indexes

The `codonUsage()` function also computes several codon indexes and performs statistical comparisons between gene sets of interest. These include the CAI (codon adaptation index)[ref], CBI (Codon Bias Index)[ref], FOP (frequency of optimal codons)[ref], L_aa (Number of AAs in protein)[ref], and tAI (tRNA adaptation index)[ref]. The type of [Visualizations](#plottingOpts) generated can be controlled as described above, using the `plotType_index` parameter. 

Below are several examples produced by the example code above.

```{r codonUsageIndexPDF, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("codonCAI_index.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/codonCAI_index.png")

image_read_pdf("codonCBI_index.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/codonCBI_index.png")

image_read_pdf("codonFop_index.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/codonFop_index.png")

# Read each image
img1 <- image_read("Figures/codonCAI_index.png")
img2 <- image_read("Figures/codonCBI_index.png")
img3 <- image_read("Figures/codonFop_index.png")

# Append them horizontally
combined <- image_append(c(img1, img2, img3), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_indexes.png")

```

```{r codonUsageIndexPNG, echo=FALSE, fig.wide = TRUE, fig.cap="Vioin plots of several codon usage indexes calculated by the codonUsage() function. Shown are several examples including CAI (left), CBI (middle), and Fop (right). Statistical comparisons are made between translationally activated (blue), suppressed (red), and background (grey) gene sets. Visualizations can be also generated as either box plots, or eCDFs"}
knitr::include_graphics("Figures/combined_indexes.png")

```

```{r codonUsageIndexHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("codonCAI_index.pdf", "codonCBI_index.pdf", "codonFop_index.pdf","codonGC3s_index.pdf","codonL_aa_index.pdf","codontAI_index.pdf",
         "Figures/codonCAI_index.png", "Figures/codonCBI_index.png",
         "Figures/codonFop_index.png"))
```

### Selecting enriched or depleted codons or amino acids

The `codonUsage()` function can also be used to identify enriched or depleted codons or AAs between gene sets of interest. In the first step of the analysis, for each gene set comparison, a Chi-square test is applied to assess significant differences in codon or AA usage. To visualize the results of this test, a clustered heatmap of the standardized Chi-square residuals for each codon or AA between the gene sets of interest can be produced using the `plotHeatmap` parameter. Then, for codons or AAs passing significance thresholds (specified using the `pAdj` parameter), the odds ratio for each desired comparison pair is calculated and plotted against the frequency. Codons or AAs of interest with differential usage between gene sets are usually identified as those with a high or low odds ratio, and high frequency. These thresholds can be defined using the `thresOddsUp`, `thresFreqUp`, `thresOddsDown` and `thresFreqDown` parameters.

In the example below, enriched and depleted codons will be identified between translationally activated and suppressed gene sets. These are defined as those with and adjusted p-value less than 0.01 in a Chi-square test, and are within the top 30\% of enrichment or depletion based on odds ratios and average frequencies.  
```{r codonUsageSelected, eval=FALSE, echo=TRUE}

# Identify enriched and depleted codons between
# translationally activated and suppressed genes

 codonUsage(ptn = ptn, 
          annotType = "ptnCDS", 
          sourceSeq = "load", 
          analysis = "codon", 
          codonN = 1, 
          pAdj = 0.01, 
          plotHeatmap = TRUE, 
          thresOddsUp = 0.3, 
          thresFreqUp = 0.3, 
          thresOddsDown = 0.3, 
          thresFreqDown = 0.3, 
          comparisons = list(c(1,2)), 
          pdfName = 'Example')
 
```

```{r codonUsageSelectedPDF, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("codon_translationUp_translationDown_heatmap.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/codon_translationUp_translationDown_heatmap.png")

image_read_pdf("codontranslationUp_translationDowncodon_oddratio_vs_freq.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/codontranslationUp_translationDowncodon_oddratio_vs_freq.png")

# Read each image
img1 <- image_read("Figures/codon_translationUp_translationDown_heatmap.png")
img2 <- image_read("Figures/codontranslationUp_translationDowncodon_oddratio_vs_freq.png")

# Append them horizontally
combined <- image_append(c(img1, img2), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_codonSelection.png")

```

```{r codonUsageSelectedPNG, echo=FALSE, fig.wide = TRUE, fig.cap="Visualizations of differential codon usage between different gene sets of interest. A clustered heatmap of standardized residuals for each codon from a Chi-square test (left), and a plot of the log2 odds ratio for each codon between translationally activated and suppressed gene sets, vs. the average codon frequency. Those passing thresholds for enrichment or depletion between gene sets are highlighted in red and blue, respectively."}
knitr::include_graphics("Figures/combined_codonSelection.png")

```

```{r codonUsageSelectedHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("codon_translationUp_translationDown_heatmap.pdf", "codontranslationUp_translationDowncodon_oddratio_vs_freq.pdf",
         "Figures/codon_translationUp_translationDown_heatmap.png", "Figures/codontranslationUp_translationDowncodon_oddratio_vs_freq.png"))
```

### Enumerating selected codons or amino acids 

After identifying codons or AAs with differential usage between gene sets using the `codonUsage()` function, these can be enumerated across genes using the `codonSelection()` function for use in modelling using `featureIntegration()`. [Statistical comparisons](#comparisons) and [visualizations](#plottingOpts) can also be generated using the parameters described above.

Codons or AAs to examine are specified using the `featSel` parameter, and the output can be calculated as either the number of occurrences per gene, or the frequency (the count per gene relative to all other codons or AAs in the gene) specified by the `unit` parameter. 

In the example below, codons identified as enriched or depleted between genes sets based on Chi-square and odds ratio analyses are enumerated for each gene, and these are compared between translationally activated and suppressed gene sets.  
```{r codonCalc, eval=TRUE, echo=TRUE}

# Select codons of interest with high frequency, and the highest and lowest odds ratios
# between translationally activated and suppressed genes 
 
 codons <- ptn_codonSelection(ptn, 
                              comparison = 1)

 codons
 
# Calculate and plot eCDFs of codon frequencies, and compare between gene sets

 codonCounts  <- codonCalc(ptn = ptn,
                          analysis = "codon", 
                          featsel = codons,
                          unit = "freq", 
                          comparisons = list(c(1,2)),
                          plotType = "ecdf")
                      
 str(codonCounts)

```

```{r codonCalcPDF, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("features_Down_codonCalc.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/features_Down_codonCalc.png")

image_read_pdf("features_Up_codonCalc.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/features_Up_codonCalc.png")

# Read each image
img1 <- image_read("Figures/features_Up_codonCalc.png")
img2 <- image_read("Figures/features_Down_codonCalc.png")

# Append them horizontally
combined <- image_append(c(img1, img2), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_codonCalc.png")

```

```{r codonCalcPNG, echo=FALSE, fig.wide = TRUE, fig.cap="eCDFs visualizing differences in the frequency of enriched (left) and depleted (right) codons between gene sets. Statistical comparisons are made between translationally activated (blue), suppressed (red) gene sets, with background shown in grey. Visualizations can be also generated as either box plots, or violin plots."}
knitr::include_graphics("Figures/combined_codonCalc.png")

```

```{r codonCalcHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("features_Down_codonCalc.pdf", "features_Up_codonCalc.pdf",
         "Figures/features_Down_codonCalc.png", "Figures/features_Up_codonCalc.png"))
```

<a name="modelling"/>

# Modelling and network analysis of post-transcriptional regulation 

## Selecting features for modelling

### *Cis*-acting features

### *Trans*-acting features

### Creating the feature list

### Highly correlated variables 

## Post-transcriptional network modelling with stepwise linear regression

### Overview

### Univariate models

### Omnibus model

### Adjusted model

### Understanding covariance and feature correlations

### Network visualizations

### Feature visualizations

## Post-transcriptional network modelling with random forest classification

### Overview

### Receiver Operating Characteristic (ROC) analysis

### Feature Importance


<a name="UMAPvis"/>

# Visualize and explore relationships between mRNA features and regulatory effects 

## Plotting UMAPs

### Clustering and colouring options

### Scaling and binary features 


<a name="networkPred"/>

# Predicting post-transcriptional regulation

## Selecting features to predict post-transcriptional regulation

## Predicting regulation in a new data set 

<a name="enrichmentAnalysis"/>

# Functional enrichment and threshold-independent signature analyses with postNet

In addition to tools for identifying and enumerating sequence features of mRNA and modeling networks of post-transcriptional regulation, postNet can also be used to perform enrichment analyses including implementations of GSEA, GAGE, and GO term analysis to provide functional insights into gene sets of interest. It is also possible to examine the regulation of gene signatures in your dataset in a threshold-independent manner, providing insights into possible mechanisms explaining observed regulation and allowing comparisons between datasets.  

## Slope filtering when using an Anota2seqDataSet object

<a name="slopeFiltering"/>

When performing GSEA, GAGE, or GO term analysis using the output of an `anota2seq` analysis, it is often necessary to filter the input genes and log2 fold changes for the "translation" and "buffering" regulatory modes prior to performing enrichment analyses. This is due to that the slopes fitted by the anota2seq APV models can sometimes have unrealistic values, or suggest unlikely translational regulation, impacting the analysis of changes in translation or translational buffering (or offsetting). Filtering out genes with these unrealistic slopes is especially important for GSEA and GAGE analyses, which rely on rankings. For analyses relying on hypergeometric tests, such as GO term enrichment, the impact of filtering on the analysis is likely to be more negligible. However, slope filtering is still recommended. The `slopeFilt` function identifies these genes with unrealistic slopes, allowing them to be removed from downstream analyses. Note that in high-quality data sets few genes will require slope filtering, but filtering thresholds can be adjusted with the `minSlope` and `maxSlope` parameters. 

```{r slopeFilt, eval=TRUE, echo=TRUE}

# Get the genes to be filtered out of downstream enrichment analyses 
# using the buffering regulatory mode:
 filtOutGenes <- slopeFilt(ads,
                  regulationGen = "buffering",
                  contrastSel = 1)
                
```

The output of the `slopeFilt()` function can be directly supplied to downstream enrichment analysis functions using the `genesSlopeFiltOut` parameter.  

```{r slopeFiltStr, eval=TRUE, echo=TRUE}
str(filtOutGenes)
```
 
## Performing GSEA with a postNetData object

PostNet performs Gene Set Enrichment Analysis (GSEA)[refs] using `gseaAnalysis()` function and the genes sets and regulatory effect measurement contained in a `postNetData` object. The analysis implements the [fgsea](https://bioconductor.org/packages/release/bioc/html/fgsea.html) package[ref], and can be applied using gene sets from The Molecular Signatures Database [msigdb](https://www.gsea-msigdb.org/gsea/index.jsp) [ref]. Gene expression signatures to be considered in the analysis can be selected from MSigDB using the `collection`, and `subcollection` parameters, and specific gene sets can be specified using `subsetNames`. Gene sets can further refined using the `maxSize` and `minSize` parameters to set upper and lower thresholds for the number of genes included in each germ set.      

The code below provides an example of how to run GSEA analysis on genes ranked according to log2 fold changes in translation efficiency, using specific gene set terms from the MSigDB. If you are using the results of an `anota2seq` analysis, it would also be necessary to perform #slopeFlitering, and supply the output using the `genesSlopeFiltOut` in both the `gseaAnalysis()` and `gseaPlot()` functions.  
```{r GSEAmsigDB, eval=FALSE, echo=TRUE}

# If using a GSEA collection from MSigDB, check the available versions:
 version <- msigdb::getMsigdbVersions()

# Retrieve the MSigDB data for "human":
 msigdbOut <- msigdb::getMsigdb(org = "hs", 
                                id = "SYM", 
                                version = version[1])

# Check the available collections or subcollections:
 msigdb::listCollections(msigdbOut)
 msigdb::listSubCollections(msigdbOut)
 
# Run GSEA on the C5 collection with GO:BP and specific terms:
 ptn <- gseaAnalysis(ptn = ptn,
                    collection = "c5",
                    subcollection = "GO:BP",
                    subsetNames = c("GOBP_CELL-CELL_SIGNALING_BY_WNT",
                    "GOBP_ENDOCYTOSIS"),
                    name = "c5_Example")
 
```

In addition to the collections in MSigDB, GSEA can also be run using custom gene sets using the `geneSet` parameter.
```{r GSEAcustom, eval=TRUE, echo=TRUE}

# Create example custom gene sets for GSEA:
set1 <- sample(myGenes[[1]], 100)
set2 <- sample(myGenes[[2]], 100)
inSet <- list(Set1 = set1, Set2 = set2)

# Run GSEA on custom gene sets:
 ptn <- gseaAnalysis(ptn = ptn,
                    geneSet = inSet,
                    name = 'Example')

```

GSEA results can be extracted from the `postNetData` object and plotted using the `ptn_GSEA()` and `gseaPlot` functions.  
```{r GSEAplotting, eval=TRUE, echo=TRUE}

# Extract the significant enrichment results from the postNetData object:
 gseaOut <- ptn_GSEA(ptn, 
                     threshold = 0.05)
 
 # Plot GSEA results:
 gseaPlot(ptn = ptn,
          termNames = gseaOut$Term[1])
```

```{r GSEAplottingPDF, eval=TRUE, echo=FALSE}
# Convert to PNG
image_read_pdf("gsea_Set1.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/gsea_Set1.png")

```

```{r GSEAplottingPNG, echo=FALSE, fig.wide = TRUE, fig.cap="A plot visualizing GSEA results for the enrichment of the gene Set1 in the example dataset."}
knitr::include_graphics("Figures/gsea_Set1.png")

```

```{r GSEAplottingHide, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("gsea_Set1.pdf","Example_gseaAnalysis.txt"))
```

## GAGE analysis with a postNetData object

Generally Applicable Gene-set Enrichment (GAGE) analysis can also be performed using the regulatory effect measurement contained in a `postNetData` object. The `gageAnalysis()` function implements the [gage](gage) package [ref], and can be used with the Biological Process "BP", Molecular Function "MF", or Cellular Component "CC" Gene Ontology categories, and well as with 'KEGG' pathways. These are specified using the `category` parameter. Similarly to GSEA, terms/pathways can filtered using the `maxSize` and `minSize` parameters to set upper and lower thresholds for the number of genes included.      

The results of the analysis can be retrieved using the `ptn_GAGE` function. As GAGE uses a two-directional test, the directionality of the results ("greater", "less") can be specified with the `direction` parameter.  
 
The example code below performs GAGE analysis using the "MF" GO term category, and extracts terms that are significantly associated with increased log2 fold changes in translation efficiency. Note that if you are using the results of an `anota2seq` analysis, it would also be necessary to perform #slopeFlitering, and supply the output using the `genesSlopeFiltOut` in the `gageAnalysis()` function.   
```{r GAGEanalysis, eval=FALSE, echo=TRUE}

# Run GAGE:
 ptn <- gageAnalysis(ptn,
                    category = "MF")

# Extract the significant enrichment results from the postNetData object:
 gageOut <- ptn_GAGE(ptn = ptn,
                    category = "MF",
                    direction = "greater", 
                    threshold = 0.05)
 
```

## GO term analysis with a postNetData object

Gene Ontology (GO) terms enrichment analysis can also be performed using the gene lists of interest in a `postNetData` object. The `goAnalysis()` function implements [clusterProfiler](clusterProfiler) [ref], and similarly to GAGE analysis can be used with the Biological Process "BP", Molecular Function "MF", or Cellular Component "CC" Gene Ontology categories, and with 'KEGG' pathways specified using the `category` parameter, with optional filtered using the `maxSize` and `minSize` parameters to set upper and lower thresholds for the number of genes included.   

The results of the analysis can be retrieved using the `ptn_GO` function. As GAGE uses a two-directional test, the directionality of the results ("greater", "less") can be specified with the `direction` parameter.     

The \code{goAnalysis} function implements \link[clusterProfiler]{clusterProfiler} to perform Gene Ontology 
enrichment analysis using the gene sets of interest associated with the regulatory effect measurement defined within \code{postNetData} object.
}

After running GO term analysis, the results can be retrieved from the \code{postNetData} object using the S4 method \link[postNet]{ptn_GO} function. Results can also be visualized using the \link[postNet]{goDotplot} function. 

Note that if using results from an \pkg{anota2seq} analysis, it is strongly recommended to first apply filtering using the \link[postNet]{slopeFilt} function to exclude genes with unrealistic regression slopes.

Generally Applicable Gene-set Enrichment (GAGE) analysis can also be performed using the regulatory effect measurement contained in a `postNetData` object. The `gageAnalysis()` function implements the [gage](gage) package [ref], and can be used with the Biological Process "BP", Molecular Function "MF", or Cellular Component "CC" Gene Ontology categories, and well as with 'KEGG' pathways. These are specified using the `category` parameter.  

The results of the analysis can be retrieved using the `ptn_GAGE` function. As GAGE uses a two-directional test, the directionality of the results ("greater", "less") can be specified with the `direction` parameter.  
 
The example code below performs GAGE analysis using the "MF" GO term category, and extracts terms that are significantly associated with increased log2 fold changes in translation efficiency. 


```{r GOanalysis, eval=FALSE, echo=TRUE}

# Run GO term analysis using a postNetData object:
 ptn <- goAnalysis(ptn = ptn, 
                  category = c("BP","KEGG"),
                  name = "Example")

# Extract the significant enrichment results for Biological Process:
 goOut <- ptn_GO(ptn, 
                 category = "BP", 
                 geneList = 'translationUp', 
                 threshold = 0.05)
 str(goOut)
 
# Plot GO term analysis results:
 goDotplot(ptn = ptn, 
          category = "BP", 
          nCategories = 50, 
          pool = T, 
          size = "geneRatio", 
          pdfName = "example")
 
```


### Plotting GO term analysis results

## miRNA enrichment analysis with a postNetData object

## Threshold-independent analysis of gene signatures

### Assessing gene signatures using the gene list workflow

### Assessing signatures from the anota2seq object workflow

### Generating gene signature heatmaps

# References
