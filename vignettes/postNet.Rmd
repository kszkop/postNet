---
title: "Post-transcriptional network modelling with postNet"
author: "Krzysztof J. Szkop, Kathleen Watt, Ola Larsson"
package: postNet
abstract: > 
  Post-transcriptional mechanisms play a central role in the regulation of gene expression, with protein levels partly determined by various features within target mRNAs. Emerging evidence indicates that most individual mRNAs contain multiple regulatory elements. This underscores the need for efficient bioinformatic tools that can capture and integrate multiple mRNA features to assess their combined impact on the proteome. Here, we present postNet modeling, a tool that enables in silico identification, integration, and modeling of mRNA features that influence post-transcriptional regulation of gene expression at a transcriptome-wide scale. Although geared towards studies of post-transcriptional regulation, postNet is highly customizable and can, in principle, be applied in a variety of other contexts to explain changes in a continuous numeric variable between two or more conditions/groups. This vignette provides details regarding the use of postNet, and demonstrates typical workflows and results interpretation. 
output: 
  BiocStyle::html_document:
    highlight: pygments
    toc: true
vignette: >
  %\VignetteIndexEntry{Post-transcriptional network modelling with postNet}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: vignette_references.bib
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, 
                      error = FALSE, 
                      warning = TRUE)
```

# Introduction

To enable efficient assessment of features underlying alterations in translational efficiencies we developed postNet, which includes methods to quantify and identify RNA features (e.g. nucleotide content, length of UTRs and CDS, folding energy of UTRs and CDS, RNA motifs, uORFs, codon composition etc.) associating with selective alterations in mRNA translation and statistical analysis of whether the catalogue of identified features appear to modulate translation in a distinct or overlapping fashion.

PostNet uses stepwise linear regressions to model changes in post-transcriptional regulation (translation, or translational offsetting) across subsets of regulated mRNAs and assesses the contribution of each feature included in the modelling in a hierarchical manner. This allows postNet to rank mRNA features according to their ability to explain changes in gene expression regulation. Furthermore, because of the hierarchical approach, the interdependence between different features is revealed. 

In the first phase of postNet modelling, each candidate feature is evaluated separately (i.e. using univariate linear models). This allows assessment of associations between changes in post-transcriptional regulation and each selected feature to provide an overview. Moreover, the univariate output is used to identify of a set of features for further modeling in phase two of the postNet analysis. In the second phase, postNet selects the feature that best explained the regulatory changes from phase one and adds additional features to the model in an iterative fashion, keeping covariance between features in the model assigned to the feature which appeared most influential. During each iteration, the best performing model (i.e. the feature showing the strongest association with the regulatory effect) is kept and features that do not explain any additional variation are discarded. This generates a hierarchical output that reveals dependence between RNA features (i.e. co-occurrence in mRNAs) identified under phase one. In the third and final phase of postNet analysis, the independent contribution of each of the features that emerged as significant from phase two is determined (i.e. in contrast to assigning covariance to the most influential feature under phase 2, such covariance is eliminated from the output to derive the independent contribution of each feature during phase three).

# Workflow 

PostNet was designed to be highly flexible in order to accommodate a variety of inputs and biological contexts. A postNet analysis can consists of the following steps: 

1) Initialize a `postNetData` object with the `postNetStart()` function, containing curated reference mRNA sequences, gene sets of interest to be compared, and a regulatory effect measurement that will be used in downstream analyses. See [Setting up a postNet analysis](#settingUp) for details.
2) Identify and quantify mRNA sequence features, and compare them between gene sets of interest. See [Analysis of mRNA sequence features](#mRNAfeatures) for details.
3) Model post-transcriptional changes in gene expression using mRNA features (or other variables) underlying regulatory processes with the `featureIntegration()` function. See [Modelling post-transcriptional regulation](#modelling) for details.
4) Perform network analysis based on stepwise regression models to understand the independent and overlapping contribution of mRNA features to post-transcriptional regulation, and use identified features to predict regulation in other data sets using machine learning with the `rfPred()`function. See [Network analysis and prediction](#networkPred)
5) Explore relationships between mRNA features (or other variables) and regulatory effects using UMAP visualizations with the `plotFeaturesMap()`function. See [Visualize and explore relationships between mRNA features and regulation](#UMAPvis)
6) Optionally, perform functional enrichment analyses on the regulated gene sets of interest. See [Functional enrichment analyses with postNet](#enrichmentAnalysis) for details.

# Getting started

Here, we demonstrate a minimal example of the steps of a standard postNet analysis workflow using an example data set illustrating changes in mRNA translation, with default parameters. This includes compiling input data and selecting reference mRNA sequence annotations, enumeration of mRNA features in regulated gene sets of interest, modelling changes in mRNA translation efficiency using stepwise regression to identify the collection of mRNA features that best explain the observed regulation (omnibus model), network analysis visualizing the independent and overlapping regulatory contribution of mRNA features, and finally exploration of modelling results using UMAP visualizations.

```{r load_package_data, eval=TRUE, echo=TRUE} 
library(postNet)
data("postNetExample")
```

**Step 1:** A `postNetData` object containing regulated gene sets of interest along with the background set, a regulatory effect measurement (in this case, log2 fold changes in translation efficiency), and reference mRNA sequence annotations in initialized using the `postNetStart()` function.   
```{r gettingStartedInput, eval=TRUE, echo=TRUE}
# Prepare custom gene lists and regulatory effect measurement:
myGenes <- postNetExample$geneList
myBg <- postNetExample$background
myEffect <- postNetExample$effect

str(myGenes)
str(myBg)
str(myEffect)

```

```{r gettingStartedInitialize, eval=TRUE, echo=TRUE, results='hide'}
# Initialize a postNetData object:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   selection = "random",
   setSeed = 123,
   source = "load", 
   species = "human"
 )

```

**Step 2:** mRNA features that may influence post-transcriptional regulation of gene expression are enumerated. In this minimal example, the length and nucleotide content of 5'UTR regions are calculated and compared between gene sets. However, numerous other features across all sequence regions can be examined (see [Analysis of mRNA sequence features](#mRNAfeatures)). These analyses allow both statistical comparisons of mRNA features between gene sets of interest, and generate outputs that can be used to assess the contribution of a given mRNA feature to the observed regulatory effect in the modelling step. 

```{r gettingStartedenumerate, eval=TRUE, echo=TRUE}
# Quantify the length and nucleotide content of the 5'UTR and compare between regulated gene sets 
len <- lengthAnalysis(ptn = ptn, 
                      region = c("UTR5"), 
                      comparisons = list(c(0,1),c(0,2),c(1,2)),
                      plotOut = TRUE,
                      plotType = 'boxplot',
                      pdfName = "Example")
                  
 str(len)
 
 content_UTR5 <- contentAnalysis(ptn = ptn, 
                           region = c("UTR5"),
                           comparisons = list(c(0,1),c(0,2),c(1,2)), 
                           contentIn = c("GC"),
                           plotOut = TRUE,
                           plotType = "ecdf",
                           pdfName = "Example")
                      
 str(content_UTR5)

```

```{r gettingStartedenumeratePDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
library(magick)
image_read_pdf("Example_UTR5_boxplot_lengthAnalysis.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_boxplot_lengthAnalysis.png")

image_read_pdf("Example_UTR5_GC_content.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_GC_content.png")

# Read each image
img1 <- image_read("Figures/Example_UTR5_boxplot_lengthAnalysis.png")
img2 <- image_read("Figures/Example_UTR5_GC_content.png")

# Append them horizontally
combined <- image_append(c(img1, img2), stack = FALSE)

# Save combined image at high resolution
image_write(combined, path = "Figures/combined_UTR5_features.png")

```

```{r gettingStartedenumeratePNGS, echo=FALSE, fig.wide = TRUE, fig.cap="Comparisons of 5'UTR length and GC content between mRNA belonging to regulated gene sets."}
knitr::include_graphics("Figures/combined_UTR5_features.png")

```

```{r gettingStartedhidePlots, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_boxplot_lengthAnalysis.pdf", "Example_UTR5_GC_content.pdf","Figures/Example_UTR5_boxplot_lengthAnalysis.png","Figures/Example_UTR5_GC_content.png"))
```

**Step 3:** Changes in translation efficiency are modeled using the `featureIntegration` function which performs stepwise regression to identify the collection of features that best explains the observed regulation. In this minimal example, a set of pre-calculated features is used including both *cis*-acting (enumerated mRNA features) and *trans*-acting (signatures of upstream regulatory pathways) factors. 

```{r gettingStartedFeatureInt, eval=TRUE, echo=TRUE}
# Prepare the list of pre-calculated features to be used in modelling (for example, the 'len' and 'content_UTR' variables defined in the previous step can be included) 
features <- postNetExample$features
str(features)

# Group the features according to category (optional)
group = c("UTR5", "UTR3", rep("UTR5",3), rep("UTR3",4), "CDS", "CDS", "UTR5", "UTR5", 
                rep("Pathway",2),"UTR5", rep("Pathway",2))
groupColour = c('#834b62','#6699cc','#e9724c','#fff275')
names(groupColour) <- c("UTR5","CDS", "UTR3","Pathway")

# Run feature integration modelling using stepwise regression
ptn <- featureIntegration(ptn = ptn, 
                          features = features, 
                          pdfName = "omnibus", 
                          regOnly = T, 
                          allFeat = F,
                          analysis_type = "lm",
                          covarFilt = 20,
                          comparisons = list(c(1,2)),
                          lmfeatGroup = group,
                          lmfeatGroupColour = groupColour,
                          NetModelSel = 'omnibus')

```

```{r gettingStartedFeatureIntPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
library(magick)
image_read_pdf("omnibus_lm_translationUp_translationDown_network.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/omnibus_lm_translationUp_translationDown_network.png")

image_read_pdf("omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.png")

```


```{r gettingStartedFeatureIntNetworkPNG, echo=FALSE, fig.cap="Network plot of the results of the stepwise regression omnibus model."}
knitr::include_graphics("Figures/omnibus_lm_translationUp_translationDown_network.png")

```

```{r gettingStartedhideFeatureIntPlots, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("omnibus_lm_translationUp_translationDown_Cockman_etal_2020_classicTOP_individually.pdf", "omnibus_lm_translationUp_translationDown_Down_individually.pdf","omnibus_lm_translationUp_translationDown_FinalModel.pdf","omnibus_lm_translationUp_translationDown_Gandin_etal_2016_mTOR_transUp_individually.pdf","omnibus_lm_translationUp_translationDown_Guan_etal_2017_Tg1_transUp_individually.pdf","omnibus_lm_translationUp_translationDown_network.pdf","omnibus_lm_translationUp_translationDown_uORFs_ATG_strong_individually.pdf","omnibus_lm_translationUp_translationDown_UTR3_C_individually.pdf","omnibus_lm_translationUp_translationDown_UTR3_T_individually.pdf","omnibus_lm_translationUp_translationDown_UTR3_T_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_A_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_length_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_SCSCGS_individually.pdf","omnibus_lm_translationUp_translationDown_UTR5_T_individually.pdf"))
```

**Step 4:** The `plotFeaturesMap()` function is used to visualize the relationship between translation efficiency and different features that were identified in the modelling step as significantly contributing to the observed translational regulation. These visualizations are also useful for exploring the overlaps between different features within the same mRNAs.  

```{r gettingStartedPlotFeautresMap, eval=TRUE, echo=TRUE}

ptn <- plotFeaturesMap(ptn,
                regOnly = TRUE,
                comparisons = list(c(1,2)),
                featSel = names(ptn_selectedFeatures(ptn, 
                                               analysis_type = "lm",
                                               comparison = 1)),
                remBinary = T,
                featCol = "UTR5_SCSCGS",
                scaled = F,
                remExtreme = 0.1,
                pdfName = 'Example')

```

```{r gettingStartedPlotFeautresMapPDFconvert, eval=TRUE, echo=FALSE}
# Convert to PNG
library(magick)
image_read_pdf("Example_UTR5_SCSCGS_featureUMAP.pdf", density = 300) %>%
  image_resize("3000x") %>%
  image_write("Figures/Example_UTR5_SCSCGS_featureUMAP.png")

```

```{r gettingStartedPlotFeautresMapPNG, echo=FALSE, fig.wide = TRUE, fig.cap="UMAP visualizing changes in translation efficiency (Effect) clustered according to features identified in the omnibus model (left), with mRNAs containing SCSCGS motifs in the 5'UTR coloured (right)."}
knitr::include_graphics("Figures/Example_UTR5_SCSCGS_featureUMAP.png")

```

```{r gettingStartedhidePlotFeautresMaps, echo = FALSE, message = FALSE, results = 'hide', eval = TRUE}
unlink(c("Example_UTR5_SCSCGS_featureUMAP.pdf"))
```

This example provided an overview of a minimal postNet workflow. Full details of alternative workflows and additional inputs and options are discussed in detail in the following sections. 

<a name="settingUp"/>

# Setting up a postNet analysis

The basic workflow of a postNet analysis aims to explain the post-transcriptional regulatory fate of mRNA based on their repertoire of *cis*-acting sequence features and/or interactions with *trans*-acting factors.  Three basic inputs are required to run a postNet analysis:

1) Reference sequence annotations that will be used to identify and/or enumerate regulatory features.
2) Gene sets of interest that undergo post-transcriptional regulation.
3) A regulatory effect measurement, for example the log2 fold change in translation efficiency between a experimental and control condition.

These inputs are compiled at the start of the analysis by initializing a `postNetData` object using the `postNetStart()` function. This class of object serves as the container for storing inputs and most outputs generated during the analysis, and is designated by `ptn` in the example code provided here. The following sections describe the different options and customizations available, along with examples illustrating how to set up a postNet analysis.

## Reference sequence annotations

Reference sequence annotations are divided according to different regions of mRNA molecules (5'UTR, CDS, and 3'UTR) to allow regions to be compared separately. The `source` parameter of the `postNetStart()` function allows the user to select from several in-built sequence annotations provided with the package, retrieve sequence annotations directly from the NCBI RefSeq database [@OLeary2016], or provide custom sequence annotations. Optionally, UTR sequences can also be adjusted if more precise sequences are available, for example those experimentally determined using approaches like CAGE, QuantSeq, or long-read sequencing, etc.

It is highly recommended to use reference sequence annotations that correspond to those that were used in generating the input gene lists. For example, if RNA sequencing reads were counted using Ensembl gene/transcript annotations, these may not always correspond well to the sequences defined by RefSeq annotations, even if identifiers have been converted to be compatible. When running `postNetStart()`, a warning message describing differences in gene identifiers between the input gene lists and the reference sequence annotations will be printed to the console. Minor differences may be acceptable depending on the application. However, larger differences may warrant either reprocessing of input data, or selecting a more compatible reference sequence annotation before proceeding with the analysis.

### Loading in-built reference sequence annotations

By default, `source = "load"` meaning `postNetStart()` will load one of the in-built reference sequence annotations provided with the package. This option is available when `species = "human"` or `"mouse"`, and several several versions can be chosen from with the `version` parameter. All in-built annotations provided with the package are based on different releases of NCBI RefSeq GRCh38 (human) and GCRm39 (mouse) genome assemblies and corresponding transcript annotations.     

It is possible to check which RefSeq release versions have in-built annotations available within the package using the `checkAvailableVersions()` function.

```{r RefSeqCheckVersions, eval=TRUE, echo=TRUE}

library(postNet)

# List RefSeq release versions of available annotations in the package
checkAvailableVersions(species = "human")
checkAvailableVersions(species = "mouse")

```

A `postNetData` object can then be initialized using the in-built reference sequence annotations, in this case using the RefSeq ver_40.202408 release version for human. Note that if no version is specified, the latest release will be used.

```{r RefSeqLoad, eval=FALSE, echo=TRUE}

data("postNetExample")

# Prepare custom gene lists and regulatory effect measurement:
myGenes <- postNetExample$geneList
myBg <- postNetExample$background
myEffect <- postNetExample$effect

# Initialize a postNetData object using in-built annotations for human:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "load", 
   species = "human",
   version = "ver_40.202408"
 )

```


### Retrieving or constructing reference sequence annotations from the NCBI RefSeq database

In addition to the in-built annotations, it is also possible to either retrieve or construct reference sequences for any RefSeq release version. Currently, only human and mouse are supported with these options. 

By specifying `source = "create"` in `postNetStart()`, annotation files from the most recent RefSeq release version for the indicated species will be automatically downloaded and used to construct a new reference sequence annotation locally. Note that downloads may take several minutes, and files will be stored in the working directory. Using this option requires an internet connection.

```{r RefSeqCreate, eval=FALSE, echo=TRUE}

# Initialize a postNetData object creating new RefSeq reference sequence annotations for human:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "create", 
   species = "human",
 )

```

Alternatively, two additional off-line methods are available to construct reference sequence annotations if files have already been downloaded from [RefSeq](https://www.ncbi.nlm.nih.gov/refseq/) and are available locally. This can be done by specifying `source = "createFromSourceFiles"` in `postNetStart()`, and providing the the RNA GBFF ("rna.gbff"), RNA FASTA ("rna.fna"), and genomic GFF ("genomic.gff") files. These files must be provided using the `rna_gbff_file`, `rna_fa_file`, and `genomic_gff_file` parameters of `postNetStart()`.    

```{r RefSeqCreateFromSourceFiles, eval=FALSE, echo=TRUE}

#  The required RefSeq annotation files downloaded from the NCBI database will 
#  have the following naming:
#  - "_rna.gbff.gz"
#  - "_rna.fa.gz"
#  - "_genomic.gff.gz"

# Initialize a postNetData object creating a new RefSeq reference sequence annotation 
# from source files:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "createFromSourceFiles",
   species = "human",
   rna_gbff_file = "_rna.gbff.gz",
   rna_fa_file = "_rna.fa.gz",
   genomic_gff_file = "_genomic.gff.gz"
 )

```

For added flexibility in defining custom sequence regions, it is also possible to assemble reference sequence annotations from a FASTA file using `source = "createFromFasta"` in `postNetStart()`. This option requires that a FASTA file be provided using the `fastaFile` parameter, along with an additional file specifying the coordinates of the mRNA sequence regions (provided with the `posFile` parameter). This position file must tab delimited and have columns indicating the transcript id, 5'UTR length, end of the coding sequence, and the total transcript length (see example below). Optionally, a genomic GFF file can also be provided using the `genomic_gff_file` parameter, however, if not GFF is provided the latest version for the indicated species will be automatically downloaded from the RefSeq database.  

```{r RefSeqCreateFromFasta, eval=FALSE, echo=TRUE}

# An example of the required format for the posFile parameter ("positions.txt"):
# id	UTR5_len	cds_stop	total_length
# NM_000014	70	4495	4610
# NM_000015	70	943	1285
# NM_000016	79	1345	2261

# Initialize a postNetData object creating a new RefSeq reference sequence annotation 
# from source files:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "createFromFasta",
   species = "human",
   fasta_file = "_rna.fa.gz",
   posFile  = "positions.txt"
   genomic_gff_file = "_genomic.gff.gz"
 )

```


### Using custom reference sequence annotations

Custom reference sequence annotations can also be used with the `postNetStart()` function and may be desirable in cases when working with data from species not currently supported by the options described above, with annotations other than those in the NCBI RefSeq database, or if sequences have been experimentally determined (for example, using long read sequencing). A pre-prepared reference sequence annotation file can be provided using the `customFile` parameter. This file must be tab delimited and contain the columns: transcriptID, geneID, UTR5_seq, CDS_seq, and UTR3_seq. 

```{r RefSeqCustom, eval=FALSE, echo=TRUE}

# An example of the required format for the customFile parameter ("customSequences.txt"):
# id	geneID	UTR5_seq	CDS_seq	UTR3_seq
# NM_000014	A2M	GGGACCAG...	ATGGGGAA...	AGACCACA...

# Initialize a postNetData object with a custom reference sequence annotation file:
ptn <- postNetStart(
   geneList = myGenes,
   geneListcolours = c("#7FB7BE","#DB7F67"),
   customBg = myBg,
   effectMeasure = myEffect,
   source = "custom",
   species = NULL,
   customFile = "customSequences.txt"
 )

```

### Selecting transcript isoforms

Using default annotations, postNet will perform gene-level analyses. selection - Specifies which mRNA isoform will be selected from the reference sequence annotation for use in analyses in cases when multiple isoforms are present for a given gene. This parameter can be one of:

\describe{
     \item{\code{"longest"}}{Selects the longest sequence isoform.}
     \item{\code{"shortest"}}{Selects the shortest sequence isoform.}
     \item{\code{"random"}}{(Default) Selects an isoform at random. Note that selecting the longest or
     shortest isoforms for all genes may skew results for some analyses. For this reason, the default
     selection is \code{"random"}. However, this may lead to slight differences in results if the \code{postNetStart} 
     function is run multiple times. For cases where multiple analyses may be run using the same data, the \code{setSeed}
     parameter can be used to ensure that random isoform selection is stable each time \code{postNetStart} is run.}
     }

  {setSeed} If \code{selection} is \code{"random"}, provide a single integer value to be used with \code{set.seed} 
  to ensure that the random isoform selection is reproducible between different runs of the \code{postNetStart} function. 
  Any integer can be provided (for example 123), however, the same value must be provided between different analyses for 
  isoform selection to be reproducible. 

 however transcript-level analyses can be performed by supplying custom sequence annotations as described above (I guess the stepwise regression using isoform-level analyses suffer from the same issue as anota2seq due to correlations between isoforms of the same genes?? Should probably discuss this a bit somewhere)
 
### Adjusting UTR sequence annotations

The transcriptome is highly diverse, with mRNA isoform expression patterns varying across cell types [ref], and between normal and disease states [ref]. The sequences of mRNA molecules can also be dynamically regulated through processes such as alternative splicing [ref], altered transcription start site usage [ref], alternative polyadenylation [ref]. Analyses relating mRNA sequence features to post-transcriptional regulation will benefit from more precise sequence annotations if these are available. For example, 5'UTRs mapped by nanoCAGE sequencing were often different from database 5'UTRs annotations [@Gandin2016]. Although entirely custom sequence annotations can be supplied, as described above, numerous sequencing approaches are available to specifically map UTRs, such as CAGE/nanoCAGE [ref] and QuantSeq [ref]. For this reason, it is also possible to adjust only UTR sequences if more specific data is available for your experimental condition or system of interest.

Custom UTR sequences can be provided to replace existing UTRs in the annotation file using the `adjObj` and `region_adj` parameters of the `postNetStart()` function. A list of custom sequences must be provided, specifying which UTR region(s) should be replaced. If custom UTR sequences are available for some, but not all genes in the existing sequence annotation, whether genes without custom sequences are kept or discarded from the analysis can by controlled using the `excl` parameter. 


keepAll. When using adjusting UTR sequences with \code{adjObj} and \code{excl} is \code{FALSE}, the \code{keepAll} parameter determines how the custom UTR sequences are integrated into the existing annotation file for genes with multiple isoforms. If \code{TRUE}, the UTR sequences in the annotation file will be replaced with the custom sequences corresponding to the same transcript IDs. However, if there are multiple transcript IDs (isoforms) for the same gene ID, all isoforms will be retained, including transcript IDs where custom sequences were not available in \code{adjObj}. Note that unless the custom sequences are always the longest or shortest isoforms that can be selected using the \code{selection} parameter, when \code{keepAll} is \code{TRUE}, the custom sequences are not guaranteed to be the ones considered if a gene-level analysis is performed. If \code{FALSE}, transcript IDs (isoforms) corresponding to the same gene that are not found in the custom sequences provided in \code{adjObj} will be removed, such that only the custom UTR sequences will be available for genes with multiple isoforms. The default is \code{FALSE}.

## Setting up a postNet analysis using gene lists

## Setting up a postNet analysis using an anota2seq object


<a name="mRNAfeatures"/>

# Analysis of mRNA sequence features

## Length of sequence regions

## Nucleotide content

## Folding energy

## upstream open reading frames (uORFs)

## Motif discovery using STREME

## Motif enumeration

## Codon and amino acid usage

### Selecting enriched or depleted codons or amino acids

### Enumerating codons or amino acids 

<a name="modelling"/>

# Modelling and network analysis of post-transcriptional regulation 

## Selecting features for modelling

### *Cis*-acting features

### *Trans*-acting features

### Creating the feature list

### Highly correlated variables 

## Post-transcriptional network modelling with stepwise linear regression

### Overview

### Univariate models

### Omnibus model

### Adjusted model

### Understanding covariance and feature correlations

### Network visualizations

### Feature visualizations

## Post-transcriptional network modelling with random forest classification

### Overview

### Receiver Operating Characteristic (ROC) analysis

### Feature Importance


<a name="UMAPvis"/>

# Visualize and explore relationships between mRNA features and regulatory effects 

## Plotting UMAPs

### Clustering and colouring options

### Scaling and binary features 


<a name="networkPred"/>

# Predicting post-transcriptional regulation

## Selecting features to predict post-transcriptional regulation

## Predicting regulation in a new data set 


<a name="enrichmentAnalysis"/>

# Functional enrichment analyses with postNet

## Slope filtering with an anota2seq object

When performing GSEA, GAGE, or GO term analysis using the output of an \pkg{anota2seq} analysis, it is often necessary to filter the input 
genes and log2 fold changes for the "translation" and "buffering" regulatory modes prior to performing enrichment analyses. 
This is due to that the slopes fitted by the anota2seq APV models can sometimes have unrealistic values, or suggest unlikely translational regulation, 
impacting the analysis of changes in translation or translational buffering (or offsetting). Filtering out genes with these unrealistic slopes is especially important 
for GSEA and GAGE analyses, which rely on rankings. For analyses relying on hypergeometric tests, such as GO term enrichment, the impact of filtering 
on the analysis is likely to be more negligible. However, slope filtering is still recommended. Note that in high-quality data sets, usually 
few genes will require slope filtering.  

## Performing GSEA with a postNetData object

### Plotting GSEA results

## GAGE analysis with a postNetData object

## GO term analysis with a postNetData object

### Plotting GO term analysis results

## miRNA enrichment analysis with a postNetData object

## Threshold-independent analysis of gene signatures

### Assessing gene signatures using the gene list workflow

### Assessing signatures from the anota2seq object workflow

### Generating gene signature heatmaps



# References
